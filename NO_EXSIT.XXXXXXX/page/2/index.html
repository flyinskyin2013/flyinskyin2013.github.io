<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"e-x.top","root":"/","images":"/images","scheme":"Gemini","darkmode":true,"version":"8.27.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":false,"codeblock":{"theme":{"light":"default","dark":"stackoverflow-dark"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Sky&#39;s Blogs">
<meta property="og:url" content="https://e-x.top/NO_EXSIT.XXXXXXX/page/2/index.html">
<meta property="og:site_name" content="Sky&#39;s Blogs">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="Sky">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://e-x.top/NO_EXSIT.XXXXXXX/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"NO_EXSIT.XXXXXXX/page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Sky's Blogs</title>
  








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  






  




<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8677552300382028"
     crossorigin="anonymous"></script>
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Sky's Blogs</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A normal star</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Sky</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">139</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">92</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">222</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/08/04/blog_idx_136/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/08/04/blog_idx_136/" class="post-title-link" itemprop="url">docker&dockerd源码构建</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-08-04 18:42:00" itemprop="dateCreated datePublished" datetime="2024-08-04T18:42:00+08:00">2024-08-04</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 17:11:58" itemprop="dateModified" datetime="2024-08-18T17:11:58+08:00">2024-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/docker/" itemprop="url" rel="index"><span itemprop="name">docker</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>4 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=136） 
&emsp;&emsp;本文发布于 2024-08-04 18:42:00             （BlogID=136） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  在docker公司的网站上已经提供了绝大部分平台的预构建的安装包情况下，为什么要自己构建docker及dockerd呢？因为我们需要定制docker的一些功能或者命令，例如：增加docker命令做特殊响应，docker相关加密等等。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="docker基本架构简介">docker基本架构简介</h3>
<hr>
<p>  docker实际分为两个部分，一个是dockerd守护程序，一个是docker前端程序，他们之间通过uds连接。docker通过解析前端用户命令，并调用相关网络接口访问dockerd，dockerd执行具体的操作，并返回相关内容给docker。</p>
<p>  dockerd的源码库是：<a target="_blank" rel="noopener" href="https://github.com/moby/moby.git">https://github.com/moby/moby.git</a></p>
<p>  docker的源码库是：<a target="_blank" rel="noopener" href="https://github.com/docker/cli.git">https://github.com/docker/cli.git</a></p>
<br/>
<br/>
<br/>
<br/>
<h3 id="dockerd源码构建">dockerd源码构建</h3>
<hr>
<p>  dockerd源码构建分为两个部分：</p>
<ol>
<li class="lvl-3">
<p>构建dockerd构建环境容器：docker-dev</p>
</li>
<li class="lvl-3">
<p>使用docker-dev容器来构建dockerd程序。</p>
</li>
</ol>
<br/>
<br/>
<h5 id="docker-dev容器构建">docker-dev容器构建</h5>
<p>  执行如下命令就能够成功构建docker-dev容器：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">-b</span> xxx https://github.com/moby/moby.git
<span class="token builtin class-name">cd</span> moby
<span class="token function">make</span> build<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  一切顺利的情况下，一般来说，上面的容器环境能够成功搭建。但是如果你在国内，99%的可能性不能搭建成功。</p>
<p>  下面有几个地方需要处理：</p>
<ol>
<li class="lvl-3">
<p>moby/Dockerfile是docker-dev容器的配置文件，里面的每一个FROM指令（或者自己识别带了docker/http/https/git等下载相关指令的）下面，需要通过RUN或者ENV等等指令设置 docker/http/https/git 等环境的代理。</p>
</li>
<li class="lvl-3">
<p>moby/contrib/download-frozen-image-v2.sh文件会下载一些容器层，需要设置http/https的代理。</p>
</li>
</ol>
<br/>
<br/>
<h5 id="dockerd程序构建">dockerd程序构建</h5>
<p>  执行如下命令就能够成功构建dockerd程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> moby
<span class="token comment"># 构建x86-64 linux版本</span>
<span class="token function">docker</span> buildx bake <span class="token parameter variable">--set</span> <span class="token assign-left variable">binary.platform</span><span class="token operator">=</span>linux/amd64

<span class="token comment"># 构建arm64 linux版本</span>
<span class="token function">docker</span> buildx bake <span class="token parameter variable">--set</span> <span class="token assign-left variable">binary.platform</span><span class="token operator">=</span>linux/arm64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  构建成功后，可以在moby/bundles/binary目录里面看到对应的构建成功的文件：dockerd和docker-proxy 两个文件。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="docker-源码构建">docker 源码构建</h3>
<hr>
<p>  docker源码构建简单，基本还是和dockerd构建类似：执行如下命令就能够成功构建dockerd程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">git</span> clone <span class="token parameter variable">-b</span> xxx https://github.com/docker/cli.git
<span class="token builtin class-name">cd</span> cli
<span class="token comment"># 构建x86-64 linux版本</span>
<span class="token function">docker</span> buildx bake <span class="token parameter variable">--set</span> <span class="token assign-left variable">binary.platform</span><span class="token operator">=</span>linux/amd64

<span class="token comment"># 构建arm64 linux版本</span>
<span class="token function">docker</span> buildx bake <span class="token parameter variable">--set</span> <span class="token assign-left variable">binary.platform</span><span class="token operator">=</span>linux/arm64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  构建成功后，可以在cli/build目录里面看到对应的构建成功的文件：docker-linux-amd64 或者 docker-linux-arm64。</p>
<p>  注意，和构建dockerd的docker-dev容器类似，这里构建的时候也会拉取一些容器来构建，如果遇到了一些错误，也需要对 docker/http/https/git等尽量设置代理。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  无</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://github.com/moby/moby.git">https://github.com/moby/moby.git</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://github.com/docker/cli.git">https://github.com/docker/cli.git</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/07/28/blog_idx_135/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/28/blog_idx_135/" class="post-title-link" itemprop="url">Linux Kernel CFI机制简介及测试禁用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-28 18:51:00" itemprop="dateCreated datePublished" datetime="2024-07-28T18:51:00+08:00">2024-07-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 17:11:58" itemprop="dateModified" datetime="2024-08-18T17:11:58+08:00">2024-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=135） 
&emsp;&emsp;本文发布于 2024-07-28 18:51:00             （BlogID=135） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  当我们为android移植linux的驱动程序的时候，总会遇到一些错误，这些错误有一部分就是android 内核开启的安全的机制导致的。本文就会介绍一种内核的安全机制：Kernel Control Flow Integrity（kCFI）。</p>
<p>  此外，这里还要说明一下，Control Flow Integrity（CFI）与 Kernel Control Flow Integrity（kCFI）是不一样的，kCFI只检查函数指针，CFI还具备其他很多的检查，详情请参考：<a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a> 。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="Kernel-Control-Flow-Integrity（kCFI）原理简单介绍">Kernel Control Flow Integrity（kCFI）原理简单介绍</h3>
<hr>
<p>  Control Flow Integrity的翻译是控制流完整性，从直译来看，其实就是用一些方法保证来保证我们的指令执行到正确的位置。我们从clang官方文档知道，kCFI只检查函数指针，那么其实kCFI就是保证函数指针跳转到正确的位置，并且返回到正确的位置。</p>
<p>  从这里来看，其实我们可以看到对于函数指针来说，我们需要保护两个地方：跳转到正确的位置、返回到正确的位置。这两个地方有两个专有名词：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>forward-edge</p>
</li>
<li class="lvl-2">
<p>backward-edge</p>
</li>
</ul>
<p>  此外，我们还应该知道，在编写代码的时候，分为直接函数调用（direct function call），间接函数调用（indirect function call）。他们的示例如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">void</span> <span class="token function">target</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">//... ...</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span>fn<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// direct function call</span>
    <span class="token function">target</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//indirect function call</span>
    fn _id_fn <span class="token operator">=</span> target<span class="token punctuation">;</span>
    <span class="token function">_id_fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从示例可以知道，indirect function call其实就是函数指针这种调用形式。</p>
<p>  此外，我们还要知道，如果我们想破坏代码的执行流，那么我们必须在可写、可读、可执行的内存里面写入shellcode，并跳转到这个shellcode，否则我们的代码是无法工作的。那么显而易见的事情是，通过函数指针来调用函数，我们的目标是明确的，因此我们可以校验这些目标的原型、地址等等信息。</p>
<p>  因为我们需要验证目标的原型、地址等等信息，所以，当我们在生成可执行文件的时候，需要知道所有的函数目标的信息，这个时候，就需要一个叫做Link Time Optimization（LTO）的功能，因为只有最终可执行文件链接时，才知道所有的函数目标信息。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="kCFI演示示例">kCFI演示示例</h3>
<hr>
<p>  首先在qemu中运行一个arm64的linux模拟器，然后为linux内核配置如下内核选项：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt"># General architecture-dependent options -> LTO
CONFIG_CFI_CLANG=y
CONFIG_CFI_PERMISSIVE=y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>  我们的测试驱动例子：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h></span>  <span class="token comment">// 必须的头文件，定义了MODULE_*宏</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/kernel.h></span>  <span class="token comment">// 包含内核信息头文件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h></span>    <span class="token comment">// 包含 __init 和 __exit 宏</span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> param_int <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>param_int<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">0644</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_cfi_i</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_cfi_i\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_cfi_f</span><span class="token punctuation">(</span><span class="token keyword">float</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"hello_cfi_f\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>hello_cfi_func_i<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>hello_cfi_func_f<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">node</span> <span class="token punctuation">&#123;</span>
    hello_cfi_func_i i0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    hello_cfi_func_f f0<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    hello_cfi_func_i i1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    hello_cfi_func_f f1<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    hello_cfi_func_i i2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    hello_cfi_func_f f2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">node</span> fn_arr <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
    <span class="token punctuation">.</span>i0 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_i<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>f0 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_f<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>i1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_i<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>f1 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_f<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>i2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_i<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
    <span class="token punctuation">.</span>f2 <span class="token operator">=</span> <span class="token punctuation">&#123;</span>hello_cfi_f<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span class="token comment">// 模块初始化函数</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>

    fn_arr<span class="token punctuation">.</span>i0<span class="token punctuation">[</span>param_int<span class="token punctuation">]</span><span class="token punctuation">(</span>param_int<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Hello, World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">// 返回0表示加载成功</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 模块清理函数</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Goodbye, World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// 注册模块初始化和清理函数</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模块许可证</span>
<span class="token function">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"Your Name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模块作者</span>
<span class="token function">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"A simple Hello World Module"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 模块描述</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  我们传入参数0，执行fn_arr.i0[0]，测试正常跳转</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_135/normal.png" alt="rep_img"/></center>
    </div>
</div>  
<p>  我们传入参数1，执行fn_arr.i0[1]，测试传入参数原型不匹配（本来应该调用hello_cfi_i，实际调用hello_cfi_f）</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_135/proto.png" alt="rep_img"/></center>
    </div>
</div>    
<p>  测试数组越界访问</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_135/overflow.png" alt="rep_img"/></center>
    </div>
</div>    
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  从上面来看，kCFI一般会对调用类型、调用的目标地址进行判断，更多细节，去看CFI的具体原理。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/ControlFlowIntegrity.html">https://clang.llvm.org/docs/ControlFlowIntegrity.html</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://source.android.com/docs/security/test/kcfi">https://source.android.com/docs/security/test/kcfi</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://outflux.net/slides/2020/lca/cfi.pdf">https://outflux.net/slides/2020/lca/cfi.pdf</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/07/21/blog_idx_134/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/21/blog_idx_134/" class="post-title-link" itemprop="url">Linux安全启动及Machine Owner Key(UEFI BIOS MBR GPT GRUB)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-21 19:47:00" itemprop="dateCreated datePublished" datetime="2024-07-21T19:47:00+08:00">2024-07-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 17:11:58" itemprop="dateModified" datetime="2024-08-18T17:11:58+08:00">2024-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>7 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=134） 
&emsp;&emsp;本文发布于 2024-07-21 19:47:00             （BlogID=134） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  只要装过各种系统的人都或多或少会接触到UEFI或者BIOS这样的概念。本文也不会对这些概念进行详解，本文主要把这些概念串起来，并引入MOK(Machine Owner Key)。</p>
<p>  为什么需要MOK，是因为在使用现代linux系统时（如：PVE），如果我们需要自己安装一些自己构建的驱动（例如想实现gpu sr-iov），会用到此功能。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="UEFI-BIOS">UEFI/BIOS</h3>
<hr>
<p>  BIOS (Basic Input/Output System) 和UEFI (Unified Extensible Firmware Interface) 这两个名字或者功能我们非常的熟悉了，机器开机自检完成后，一般f2/del等进入的界面，就是这个系统在显示工作。如果我们不按f2/del等键，系统会默默运行BIOS或者UEFI，然后自动加载引导程序，然后加载OS来运行。</p>
<p>  UEFI主要是为了取代BIOS系统的，因为其有：支持更多分区、启动速度快、支持更多硬件、更加安全、维护简单（统一标准）等等优点。其有个大的缺点就是，有些时候会因为安全的问题，需要更多的设置过程。</p>
<p>  对于BIOS来说，机器开机自检完成后，自动读取MBR（Master boot record），一般在磁盘的开始的扇区，然后加载OS或者其他进行启动。注意，这里MBR分区是一种老旧的分区格式了。</p>
<p>  对于UEFI来说，机器开机自检完成后，自动读取GPT分区(GUID Partition Table)中的EFI分区，然后加载OS或者其他进行启动。</p>
<p>  总的来说，随着时间的推进，UEFI是一种标准，已经被各大厂商支持和实现了。BIOS其已经完成了其历史的作用，除了为了兼容老机器，否则我们不应该使用它。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="Linux-在UEFI下，自构建驱动安装问题">Linux 在UEFI下，自构建驱动安装问题</h3>
<hr>
<p>  这里有一个背景知识，那就是现代的linux内核，在加载内核驱动的时候，一般都会对内核驱动做一系列校验，其中一项就是做签名校验，如果校验失败，内核拒绝加载驱动。对于这部分内容，可以参考《Linux驱动加载源码分析（安全加载 、签名、校验）》 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18301894">https://www.cnblogs.com/Iflyinsky/p/18301894</a> 一文。</p>
<p>  在《常用加密及其相关的概念、简介（对称、AES、非对称、RSA、散列、HASH、消息认证码、HMAC、签名、CA、数字证书、base64、填充）》 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18076852">https://www.cnblogs.com/Iflyinsky/p/18076852</a> 中我们介绍了签名的原理，这里简单提一下：首先有非对称加密算法生成公钥、私钥。然后对消息进行摘要，对摘要进行私钥加密得到签名，最后可以用公钥来验证（解密）此签名是否正确。</p>
<p>  那么对应到内核驱动签名验证这里就是：首先对驱动模块使用私钥进行签名，并将签名文件写入驱动模块文件中，当我们加载驱动模块时，内核会使用其带的公钥来对驱动模块进行签名验证。</p>
<p>  注意，这里有一个重要的问题是：内核带的公钥是哪里来的？一般来说，有两个渠道可以增加内核的公钥，一个是编译内核的时候，一个是通过运行时的一些方法动态写入一些公钥到内核。</p>
<br/>
<br/>
<h3 id="Machine-Owner-Key">Machine Owner Key</h3>
<hr>
<p>  在实际我们自己测试自己的驱动模块的时候，一般都会自己生成一个私钥，公钥对来对自己的驱动模块进行签名。但是在启用的UEFI+ 支持安全启动的linux系统上，我们的驱动模块是无法正常加载的，因为我们的驱动无法过签名验证。</p>
<p>  从上面的描述来看，如果要成功加载我们的内核模块，那么我们应该把我们的公钥传给内核。</p>
<p>  在解决怎么把公钥传给内核前，我们第一步要简单了解一下linux secure boot的简单流程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>机器开机及硬件自检完成，然后进入uefi固件,uefi固件里面有微软公钥。</p>
</li>
<li class="lvl-2">
<p>uefi加载shim固件（独立与linux发行版，被微软私钥预先签名，例如这个包： <a target="_blank" rel="noopener" href="https://packages.debian.org/sid/amd64/shim-signed">https://packages.debian.org/sid/amd64/shim-signed</a> ）。此外shim有各大发行版公钥。</p>
</li>
<li class="lvl-2">
<p>shim固件加载grub固件（grub固件被各大发行版私钥签名）。</p>
</li>
<li class="lvl-2">
<p>grub加载linux签名内核。</p>
</li>
</ul>
<p>  其实从上面的流程来看，就是一环环签名校验，保证了信任链的传递。</p>
<p>  回到我们之前的问题，我们怎么把我们私钥、公钥传给内核呢？必定是有一个工具能够将相关信息传进去，这个工具就是mokutil工具。</p>
<br/>
<br/>
<h5 id="mokutil">mokutil</h5>
<p>  简而言之，shim除了自带发行版的公钥外，还维护一个用户可以操作的密钥数据库，里面存储的是Machine Owner Key。通过mokutil工具，我们可以增加和删除这些密钥。这样我们就可以将我们自己的模块签名公钥嵌入到了UEFI启动流程中去，然后根据适当的方法即可交给内核使用，并能够加载我们自己密钥签名的驱动程序。</p>
<p>  mokutil工具添加过程:</p>
<ol>
<li class="lvl-3">
<p>导入公钥</p>
</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mokutil <span class="token parameter variable">--import</span> /var/lib/dkms/mok.pub 
<span class="token comment"># 并输入一次性密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<ol start="2">
<li class="lvl-3">
<p>重启系统，此时新一次的uefi的启动流程会启动mok管理器，让用户按照要求注册新的密钥，并输入之前的一次性密码。(弹个框，自己选择，输入密码即可)</p>
</li>
<li class="lvl-3">
<p>这样启动系统后，我们的密钥成功加载。</p>
</li>
<li class="lvl-3">
<p>测试系统是否成功注册密码</p>
</li>
</ol>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mokutil --test-key /var/lib/dkms/mok.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  这样我们就可以使用mok.pub对应的私钥对我们的驱动进行签名，然后就可以正常使用公钥验证，然后加载驱动了。</p>
<p>  此外，这里还要多提一下，其实android的安全加载也有类似的过程，也是两个要点：信任链传递、驱动签名。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  了解了越来越多计算机的知识，不得不感叹：知识总是不经意间出现在日常生活工作中。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://wiki.debian.org/UEFI">https://wiki.debian.org/UEFI</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://wiki.debian.org/SecureBoot">https://wiki.debian.org/SecureBoot</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.redhat.com/zh_hans/documentation/red_hat_enterprise_linux/7/html/kernel_administration_guide/sect-signing-kernel-modules-for-secure-boot">https://docs.redhat.com/zh_hans/documentation/red_hat_enterprise_linux/7/html/kernel_administration_guide/sect-signing-kernel-modules-for-secure-boot</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18301894">https://www.cnblogs.com/Iflyinsky/p/18301894</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18076852">https://www.cnblogs.com/Iflyinsky/p/18076852</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/07/14/blog_idx_133/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/07/14/blog_idx_133/" class="post-title-link" itemprop="url">Linux驱动加载源码分析（安全加载 、签名、校验）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-07-14 19:12:00" itemprop="dateCreated datePublished" datetime="2024-07-14T19:12:00+08:00">2024-07-14</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-08-18 17:11:58" itemprop="dateModified" datetime="2024-08-18T17:11:58+08:00">2024-08-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>8 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=133） 
&emsp;&emsp;本文发布于 2024-07-14 19:12:00            （BlogID=133） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  很久很久以前，在android上面移植linux驱动的时候，由于一些条件限制，导致我们测试驱动非常的麻烦。其中有一个麻烦就是驱动校验失败，然后内核拒绝加载驱动。</p>
<p>  原则上来说，只要你对驱动进行签名或者配置，就能加载成功，但是当时赶时间验证，就想着直接把驱动校验部分的代码直接屏蔽了，达到了我们测试的目的。</p>
<p>  现在过了许久了，现在有经历来重温一下当初的问题，看看根源是什么，于是我们得了解驱动加载的通用流程，查看我们的驱动到底因为哪些原因加载失败。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="linux驱动加载流程">linux驱动加载流程</h3>
<hr>
<p>  首先，我们知道linux驱动有两个关键入口函数,一般被module_init()/module_exit()宏进行处理。当我们想加载一个linux驱动的时候，一般我们使用insmod/modprobe来加载驱动，下面我们来看看执行insmod/modprobe时，到底发生了什么？</p>
<p>  经过简单的查询资料，驱动的处理涉及两个linux系统调用，他们是：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_init_module<span class="token punctuation">,</span> <span class="token keyword">void</span> module_image<span class="token punctuation">[</span><span class="token punctuation">.</span>len<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>param_values<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">syscall</span><span class="token punctuation">(</span>SYS_finit_module<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span>
            <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>param_values<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>  根据man手册介绍，SYS_init_module三个参数分别是内核驱动文件内容、文件内容长度、内核驱动参数。</p>
<p>  下面我们深入内核看看，执行SYS_init_module时，到底发生了什么？</p>
<p>  根据linux v6.9.6 kernel/module/main.c文件</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token function">SYSCALL_DEFINE3</span><span class="token punctuation">(</span>init_module<span class="token punctuation">,</span> <span class="token keyword">void</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> umod<span class="token punctuation">,</span>
		<span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> uargs<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> err<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">load_info</span> info <span class="token operator">=</span> <span class="token punctuation">&#123;</span> <span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

    <span class="token comment">// ... ...</span>

	err <span class="token operator">=</span> <span class="token function">copy_module_from_user</span><span class="token punctuation">(</span>umod<span class="token punctuation">,</span> len<span class="token punctuation">,</span> <span class="token operator">&amp;</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ... ...</span>

	<span class="token keyword">return</span> <span class="token function">load_module</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>info<span class="token punctuation">,</span> uargs<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这里最重要的就是通过copy_module_from_user给struct load_info赋值。</p>
<p>  然后到了load_module函数（根据linux v6.9.6 kernel/module/main.c文件）：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">load_module</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">load_info</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span>uargs<span class="token punctuation">,</span>
		       <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>mod<span class="token punctuation">;</span>
	bool module_allocated <span class="token operator">=</span> false<span class="token punctuation">;</span>
	<span class="token keyword">long</span> err <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">char</span> <span class="token operator">*</span>after_dashes<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Do the signature check (if any) first. All that
	 * the signature check needs is info->len, it does
	 * not need any of the section info. That can be
	 * set up later. This will minimize the chances
	 * of a corrupt module causing problems before
	 * we even get to the signature check.
	 *
	 * The check will also adjust info->len by stripping
	 * off the sig length at the end of the module, making
	 * checks against info->len more correct.
	 */</span>
	err <span class="token operator">=</span> <span class="token function">module_sig_check</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> free_copy<span class="token punctuation">;</span>

	<span class="token comment">/*
	 * Do basic sanity checks against the ELF header and
	 * sections. Cache useful sections and set the
	 * info->mod to the userspace passed struct module.
	 */</span>
	err <span class="token operator">=</span> <span class="token function">elf_validity_cache_copy</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> free_copy<span class="token punctuation">;</span>

	err <span class="token operator">=</span> <span class="token function">early_mod_check</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> free_copy<span class="token punctuation">;</span>
    
	<span class="token comment">/* Figure out module layout, and allocate all the memory. */</span>
	mod <span class="token operator">=</span> <span class="token function">layout_and_allocate</span><span class="token punctuation">(</span>info<span class="token punctuation">,</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IS_ERR</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		err <span class="token operator">=</span> <span class="token function">PTR_ERR</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token keyword">goto</span> free_copy<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>


    <span class="token comment">// ... ...</span>

    <span class="token keyword">return</span> <span class="token function">do_init_module</span><span class="token punctuation">(</span>mod<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ... ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  在 load_module 中，我们找到了3个重要的验证接口，一个是签名验证、一个是elf文件验证、一个是模块本身的信息验证。其中签名验证、模块本身的信息验证就是本文要关注的地方。经过了一系列的验证和初始化后，调用了do_init_module接口。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> noinline <span class="token keyword">int</span> <span class="token function">do_init_module</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>mod<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mod_initfree</span> <span class="token operator">*</span>freeinit<span class="token punctuation">;</span>

    <span class="token comment">//... ...</span>
	<span class="token comment">/* Start the module */</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>mod<span class="token operator">-></span>init <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
		ret <span class="token operator">=</span> <span class="token function">do_one_initcall</span><span class="token punctuation">(</span>mod<span class="token operator">-></span>init<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">goto</span> fail_free_freeinit<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token function">pr_warn</span><span class="token punctuation">(</span><span class="token string">"%s: '%s'->init suspiciously returned %d, it should "</span>
			<span class="token string">"follow 0/-E convention\n"</span>
			<span class="token string">"%s: loading module anyway...\n"</span><span class="token punctuation">,</span>
			<span class="token constant">__func__</span><span class="token punctuation">,</span> mod<span class="token operator">-></span>name<span class="token punctuation">,</span> ret<span class="token punctuation">,</span> <span class="token constant">__func__</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">dump_stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>    

    <span class="token comment">//... ...</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  看这里的do_one_initcall(mod-&gt;init)，就相当于调用了我们通过module_init()定义的接口了。</p>
<p>  但是这里有一个问题？那就是mod-&gt;init是module_init()定义的接口，那它是怎么赋值的呢？要回答这个问题，还要回到我们创建一个ko文件的时候，有两个地方我们需要关注，这里我们随便创建一个helloworld的驱动为例：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Each module must use one module_init(). */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">module_init</span><span class="token expression"><span class="token punctuation">(</span>initfn<span class="token punctuation">)</span>					</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token class-name">initcall_t</span> __maybe_unused <span class="token function">__inittest</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>		</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token punctuation">&#123;</span> <span class="token keyword">return</span> initfn<span class="token punctuation">;</span> <span class="token punctuation">&#125;</span>					</span><span class="token punctuation">\</span>
	<span class="token expression"><span class="token keyword">int</span> <span class="token function">init_module</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token function">__copy</span><span class="token punctuation">(</span>initfn<span class="token punctuation">)</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">alias</span><span class="token punctuation">(</span>#initfn<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span></span>

<span class="token keyword">static</span> <span class="token keyword">int</span> __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Hello, World!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span> 
<span class="token punctuation">&#125;</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  上面可以看到，我们通过module_init()这个宏，我们声明了一个叫做init_module函数，且此函数是hello_init的别名(alias是gcc的扩展用法)，换句话说我们调用init_module就等于调用了hello_init。</p>
<p>  此外，在我们生成ko文件的时候，还会看到一个被创建的xxx.mod.c的文件，里面有一个地方定义很重要：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">__visible <span class="token keyword">struct</span> <span class="token class-name">module</span> __this_module
<span class="token function">__section</span><span class="token punctuation">(</span><span class="token punctuation">.</span>gnu<span class="token punctuation">.</span>linkonce<span class="token punctuation">.</span>this_module<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">.</span>name <span class="token operator">=</span> KBUILD_MODNAME<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>init <span class="token operator">=</span> init_module<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_MODULE_UNLOAD</span></span>
	<span class="token punctuation">.</span>exit <span class="token operator">=</span> cleanup_module<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token punctuation">.</span>arch <span class="token operator">=</span> MODULE_ARCH_INIT<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  注意看这里的__this_module这个变量，这个变量其成员有init_module这个函数的地址信息，也就有了hello_init的地址信息，且这个__this_module变量被放到了.gnu.linkonce.this_module这个section里面。</p>
<p>  如果了解elf文件格式的，一定对section这个东西不陌生，其存放了很多elf相关内容，在这里，我们只需要关注.gnu.linkonce.this_module小节，就是__this_module的地址，这个会在驱动加载的时候用上。</p>
<p>  上面我们知道了init_module被放置到__this_module.init字段去了，那么执行do_one_initcall(mod-&gt;init)时，mod-&gt;init是怎么初始化的呢？下面我们接着分析mod-&gt;init的赋值，首先我们要回到SYS_init_module调用时，有一个load_module函数，在load_module函数中，有一个elf_validity_cache_copy()函数：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">elf_validity_cache_copy</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">load_info</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span>
	Elf_Shdr <span class="token operator">*</span>shdr<span class="token punctuation">,</span> <span class="token operator">*</span>strhdr<span class="token punctuation">;</span>
	<span class="token keyword">int</span> err<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_mod_secs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> mod_idx<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_info_secs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> info_idx<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> num_sym_secs <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> sym_idx<span class="token punctuation">;</span>

	<span class="token comment">//... ...</span>
	<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> info<span class="token operator">-></span>hdr<span class="token operator">-></span>e_shnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		shdr <span class="token operator">=</span> <span class="token operator">&amp;</span>info<span class="token operator">-></span>sechdrs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
		<span class="token keyword">switch</span> <span class="token punctuation">(</span>shdr<span class="token operator">-></span>sh_type<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			<span class="token comment">// ... ...</span>
		<span class="token keyword">default</span><span class="token operator">:</span>
			<span class="token comment">// ... ...</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>info<span class="token operator">-></span>secstrings <span class="token operator">+</span> shdr<span class="token operator">-></span>sh_name<span class="token punctuation">,</span>
				   <span class="token string">".gnu.linkonce.this_module"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				num_mod_secs<span class="token operator">++</span><span class="token punctuation">;</span>
				mod_idx <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">strcmp</span><span class="token punctuation">(</span>info<span class="token operator">-></span>secstrings <span class="token operator">+</span> shdr<span class="token operator">-></span>sh_name<span class="token punctuation">,</span>
				   <span class="token string">".modinfo"</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				num_info_secs<span class="token operator">++</span><span class="token punctuation">;</span>
				info_idx <span class="token operator">=</span> i<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token comment">// ... ...</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token comment">// ... ...</span>
	info<span class="token operator">-></span>index<span class="token punctuation">.</span>mod <span class="token operator">=</span> mod_idx<span class="token punctuation">;</span>

	<span class="token comment">/* This is temporary: point mod into copy of data. */</span>
	info<span class="token operator">-></span>mod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>info<span class="token operator">-></span>hdr <span class="token operator">+</span> shdr<span class="token operator">-></span>sh_offset<span class="token punctuation">;</span>

	<span class="token comment">/// ... ...	</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这里其实就是遍历section数组，然后得到.gnu.linkonce.this_module在section数组中的idx，并记录到info-&gt;index.mod中。（此处如果不明白，建议可以简单看看elf格式介绍，本文不分析这个）</p>
<p>  然后在load_module函数中的layout_and_allocate()中，会处理info-&gt;index.mod：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span><span class="token function">layout_and_allocate</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">load_info</span> <span class="token operator">*</span>info<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>mod<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> ndx<span class="token punctuation">;</span>
	<span class="token keyword">int</span> err<span class="token punctuation">;</span>

	<span class="token comment">// ... ...</span>

	<span class="token comment">/* Module has been copied to its final place now: return it. */</span>
	mod <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>info<span class="token operator">-></span>sechdrs<span class="token punctuation">[</span>info<span class="token operator">-></span>index<span class="token punctuation">.</span>mod<span class="token punctuation">]</span><span class="token punctuation">.</span>sh_addr<span class="token punctuation">;</span>
	<span class="token function">kmemleak_load_module</span><span class="token punctuation">(</span>mod<span class="token punctuation">,</span> info<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> mod<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  在此函数对mod赋值的过程中，就把ko文件的__this_module变量的地址，绑定给了mod，然后mod往后面传，就可以执行mod-&gt;init函数了，也就是执行hello_init。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="驱动校验加载">驱动校验加载</h3>
<hr>
<p>  对上文我们提到的load_module中有三个驱动校验相关的函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>module_sig_check</p>
</li>
<li class="lvl-2">
<p>elf_validity_cache_copy</p>
</li>
<li class="lvl-2">
<p>early_mod_check</p>
</li>
</ul>
<p>  其中elf_validity_cache_copy是对驱动二进制格式进行校验的，一般我们正常的驱动是满足条件的。因此，我们主要是去解决module_sig_check和early_mod_check的问题。</p>
<p>  对于module_sig_check来说，就是利用签名算法（可参考之前文章《常用加密及其相关的概念、简介（对称、AES、非对称、RSA、散列、HASH、消息认证码、HMAC、签名、CA、数字证书、base64、填充）》 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18076852">https://www.cnblogs.com/Iflyinsky/p/18076852</a> ），保证内核驱动使用了内核认可的私钥进行签名，然后内核使用公钥进行验证。</p>
<p>  对于early_mod_check来说，就是校验内核版本信息、模块信息等等，这里就不详细介绍了。</p>
<p>  总的来说，如果我们要关闭内核的相关校验，可以通过以下的配置，或者直接处理module_sig_check、early_mod_check两个函数即可达到我们的目的。</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">CONFIG_MODULE_SIG=y
CONFIG_MODULE_SIG_FORCE=y
CONFIG_MODULE_SIG_ALL=y
CONFIG_MODULE_SIG_SHA256=y
CONFIG_MODVERSIONS=y<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  特别注意，如果是在android系统里面，有些情况下（例如qcom的源码），你关闭了这些检测，会导致android系统编译失败，因为android kernel配置的安全检测无法通过。所以需要直接修改module_sig_check和early_mod_check函数，直接返回通过即可，这样即可测试。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  通过阅读源码，感觉对内核各个模块的工作越来越熟悉了。</p>
<p>  但是越了解的多，越觉得未知越多。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>《常用加密及其相关的概念、简介（对称、AES、非对称、RSA、散列、HASH、消息认证码、HMAC、签名、CA、数字证书、base64、填充）》  <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18076852">https://www.cnblogs.com/Iflyinsky/p/18076852</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/05/18/blog_idx_132/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/18/blog_idx_132/" class="post-title-link" itemprop="url">Linux 文件系统(三) --- overlayfs简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2024-05-18 19:19:00 / 修改时间：19:23:26" itemprop="dateCreated datePublished" datetime="2024-05-18T19:19:00+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>828</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=132） 
&emsp;&emsp;本文发布于 2024-05-18 19:19:00             （BlogID=132） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  对于overlay文件系统来说，我以前只是听过，具体貌似docker里面使用了相关技术，但是也仅仅限于听过了。</p>
<p>  最近，由于需要通过tar来备份一个系统的rootfs来做测试，我发现了很多重复备份的内容，一看，嘿，可能是overlay文件系统导致的，因此，我可能需要先了解了解这个文件系统是干嘛的，然后才能够采取合适的方案来备份rootfs。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="实现大致原理">实现大致原理</h3>
<hr>
<p>  overlayfs主要是结合了两个文件系统 – “upper fs”  和  “lower fs” 。其组成规则是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当&quot;upper fs&quot;和  &quot;lower fs&quot;存在两个相同的名字的文件时，&quot;upper fs&quot;的文件是可见的，&quot;lower fs&quot;的文件是隐藏的。</p>
</li>
<li class="lvl-2">
<p>当&quot;upper fs&quot;和  &quot;lower fs&quot;存在两个相同的名字的目录时，会合并两个目录的文件。</p>
</li>
</ul>
<p>  overlayfs主要是涉及目录的操作，其挂载命令是：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 堆叠两个目录，合并lower目录，upperdir目录，展示到merge目录</span>
<span class="token comment"># workdir和upperdir必须是同一个文件系统的空目录</span>
<span class="token function">mount</span> <span class="token parameter variable">-t</span> overlay overlay <span class="token parameter variable">-olowerdir</span><span class="token operator">=</span>/lower,upperdir<span class="token operator">=</span>/upper,workdir<span class="token operator">=</span>/work /merged

<span class="token comment"># 堆叠多个目录（从最右边的目录开始向左堆叠），合并lower3，lower2，lower1，展示到merged目录</span>
<span class="token function">mount</span> <span class="token parameter variable">-t</span> overlay overlay <span class="token parameter variable">-olowerdir</span><span class="token operator">=</span>/lower1:/lower2:/lower3 /merged<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  对， 本文的内容已经完了，overlay的大致工作原理和工作效果和说完了。</p>
<p>  其他细节，请参考 参考小节。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  不知道大家注意到没有，我们在描述其组合的规则的时候，对于：隐藏&quot;lower fs&quot;的文件、合并两个目录的文件  的操作说的是那么的自然，但是其是怎么实现的呢？其实这才是overlayfs的一些实际技术原理。</p>
<p>  其实，这一切都与linux的vfs和ext文件系统有一些关系，详情请参考本文的前置文章：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>《Linux 文件系统(一) — ext4文件系统简介》 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18162137">https://www.cnblogs.com/Iflyinsky/p/18162137</a></p>
</li>
<li class="lvl-2">
<p>《Linux 文件系统(二) — vfs简单分析》 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18187558">https://www.cnblogs.com/Iflyinsky/p/18187558</a></p>
</li>
</ul>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://docs.kernel.org/filesystems/overlayfs.html">https://docs.kernel.org/filesystems/overlayfs.html</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/05/12/blog_idx_131/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/05/12/blog_idx_131/" class="post-title-link" itemprop="url">Linux 文件系统(二) --- vfs简单分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-05-12 10:29:00" itemprop="dateCreated datePublished" datetime="2024-05-12T10:29:00+08:00">2024-05-12</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-18 19:06:02" itemprop="dateModified" datetime="2024-05-18T19:06:02+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=131） 
&emsp;&emsp;本文发布于 2024-05-12 10:29:00            （BlogID=131） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  VFS(Virtual File System)是一种软件抽象，主要还是为了连接用户态、内核态和实际文件系统本身。例如：我们可以write一个字符串到磁盘ext4 fs上的某个文件。</p>
<p>  在linux里面，有各种各样的文件系统，它们实际存放的位置可能是硬盘（ext4fs等）、RAM(sysfs, procfs, devtmpfs等)、网络(nfs等)等等存储介质。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="VFS的基础知识">VFS的基础知识</h3>
<hr>
<p>  这里主要介绍VFS的基础知识,以及我们常见的文件操作怎么对应到VFS里面，主要以ext4 fs与vfs的关联为例子.</p>
<br/>
<br/>
<h5 id="Directory-Entry-Cache-dcache">Directory Entry Cache (dcache)</h5>
<p>  在vfs里面提供了一种缓存机制，缓存struct dentry项，这个dcache在内核里面表示了一个文件系统的整个文件目录信息（从根目录开始的一个目录信息），但是作为一种cache数据结构，一般会存在cache miss然后创建对应struct dentry。这样就可以很快的查找到我们传入的一个路径的文件对于的struct dentry项。</p>
<p>  vfs通过我们常见的open接口操作文件时，一般是用路径来标识一个文件名的，那么怎么将我们传入的名字转换成对应的目录/文件信息呢？答案就是上面提到的dcache数据结构，通过查询dcache得到目录/文件信息，这个部分的内容也是open系统调用常常做的事情。</p>
<p>  下面是dcache项的基本定义：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">/* RCU lookup touched fields */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">int</span> d_flags<span class="token punctuation">;</span>		<span class="token comment">/* protected by d_lock */</span>
	<span class="token class-name">seqcount_spinlock_t</span> d_seq<span class="token punctuation">;</span>	<span class="token comment">/* per dentry seqlock */</span>
	<span class="token keyword">struct</span> <span class="token class-name">hlist_bl_node</span> d_hash<span class="token punctuation">;</span>	<span class="token comment">/* lookup hash list */</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>d_parent<span class="token punctuation">;</span>	<span class="token comment">/* parent directory */</span>
	<span class="token keyword">struct</span> <span class="token class-name">qstr</span> d_name<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span>d_inode<span class="token punctuation">;</span>		<span class="token comment">/* Where the name belongs to - NULL is
					 * negative */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span> d_iname<span class="token punctuation">[</span>DNAME_INLINE_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* small names */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>d_sb<span class="token punctuation">;</span>	<span class="token comment">/* The root of the dentry tree */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  还记得我们在《Linux 文件系统(一) — ext4文件系统简介》（ <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Iflyinsky/p/18162137">https://www.cnblogs.com/Iflyinsky/p/18162137</a> ）中提到，目录也是一种文件嘛？文件又是用inode来表示的，那么struct dentry就可以得到对应的struct inode信息了。</p>
<br/>
<br/>
<h5 id="struct-inode-对象">struct inode 对象</h5>
<p>  大家应该都听过一句话，在unix里面，一切皆文件。那么对于vfs来说，一个独立的文件就是struct inode对象.</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Keep mostly read-only and often accessed (especially for
 * the RCU path lookup and 'stat' data) fields at the beginning
 * of the 'struct inode'
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token punctuation">&#123;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span>	<span class="token operator">*</span>i_op<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">super_block</span>	<span class="token operator">*</span>i_sb<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">address_space</span>	<span class="token operator">*</span>i_mapping<span class="token punctuation">;</span>	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  其实这个struct inode和struct ext4_inode有许多相似的属性，他们也有些许关联。</p>
<p>  对于struct inode来说，很重要的就是struct inode_operations，这个代表着我们可以对这个inode进行的操作，其结构大概如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token operator">*</span>lookup<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>create<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">mnt_idmap</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span>
		       <span class="token class-name">umode_t</span><span class="token punctuation">,</span> bool<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>link<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>unlink<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  根据父目录的对应的lookup函数，我们可以查找对应的文件inode信息。此外，还有创建删除inode节点的方法，这些方法在文件系统装载的时候实现。</p>
<br/>
<br/>
<h5 id="struct-file-对象">struct file 对象</h5>
<p>  我们上面讲的struct dentry和struct inode是和对应的文件系统存储的数据是息息相关的。但是实际我们操作文件的第一步是打开文件，对于一个打开的文件，在内核里面使用struct file来标识，其结构如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">path</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token operator">*</span>mnt<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>dentry<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * f_&#123;lock,count,pos_lock&#125; members can be highly contended and share
 * the same cacheline. f_&#123;lock,mode&#125; are very frequently used together
 * and so share the same cacheline as well. The read-mostly
 * f_&#123;path,inode,op&#125; are kept on a separate cacheline.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token punctuation">&#123;</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token keyword">struct</span> <span class="token class-name">path</span>		f_path<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">inode</span>		<span class="token operator">*</span>f_inode<span class="token punctuation">;</span>	<span class="token comment">/* cached value */</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span>	<span class="token operator">*</span>f_op<span class="token punctuation">;</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  对于一个file对象来说，除了上面提到的struct dentry和struct inode关联外，还有一个重要的结构是：struct file_operations，对于这个结构来说，大家应该非常的熟悉，包含了open/close/read/write等等接口：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">file_operations</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span>
	<span class="token class-name">loff_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>llseek<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>read<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token class-name">ssize_t</span> <span class="token punctuation">(</span><span class="token operator">*</span>write<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> __user <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token class-name">size_t</span><span class="token punctuation">,</span> <span class="token class-name">loff_t</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>open<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">file</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  到这里，其实我们vfs我们常见用到的基本就讲完了，串起来是说就是open一个文件，创建一个struct file对象，关联一个struct dentry和struct inode，这时就可以对文件进行操作了.</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="VFS的深入知识">VFS的深入知识</h3>
<hr>
<p>  </p>
<br/>
<br/>
<h5 id="FileSystem-的注册和取消注册">FileSystem 的注册和取消注册</h5>
<p>  我们前面提到了，vfs最终会对接到实际文件系统本身，那么VFS支持哪些FS呢？在linux的/proc/filesystems文件中，存放了当前注册到vfs的所有支持的FS。</p>
<p>  下面我们介绍文件系统的注册和取消注册：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Filesystem context for holding the parameters used in the creation or
 * reconfiguration of a superblock.
 *
 * Superblock creation fills in ->root whereas reconfiguration begins with this
 * already set.
 *
 * See Documentation/filesystems/mount_api.rst
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">fs_context</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">fs_context_operations</span> <span class="token operator">*</span>ops<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mutex</span>		uapi_mutex<span class="token punctuation">;</span>	<span class="token comment">/* Userspace access mutex */</span>
	<span class="token keyword">struct</span> <span class="token class-name">file_system_type</span>	<span class="token operator">*</span>fs_type<span class="token punctuation">;</span>
	<span class="token keyword">void</span>			<span class="token operator">*</span>fs_private<span class="token punctuation">;</span>	<span class="token comment">/* The filesystem's context */</span>
	<span class="token keyword">void</span>			<span class="token operator">*</span>sget_key<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span>		<span class="token operator">*</span>root<span class="token punctuation">;</span>		<span class="token comment">/* The root and superblock */</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>name<span class="token punctuation">;</span> <span class="token comment">//文件系统名字，例如ext4</span>
        <span class="token keyword">int</span> fs_flags<span class="token punctuation">;</span>
        <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>init_fs_context<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">fs_context</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">fs_parameter_spec</span> <span class="token operator">*</span>parameters<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>mount<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span>
                <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>kill_sb<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">module</span> <span class="token operator">*</span>owner<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span> next<span class="token punctuation">;</span>
        <span class="token keyword">struct</span> <span class="token class-name">hlist_head</span> fs_supers<span class="token punctuation">;</span>
		
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/fs.h></span></span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">register_filesystem</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> <span class="token keyword">int</span> <span class="token function">unregister_filesystem</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">file_system_type</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  在register_filesystem/unregister_filesystem函数里面，主要是对内核里面的file_system_type变量进行链表操作，注册就是增加链表节点，取消注册就是删除链表节点。</p>
<br/>
<br/>
<h5 id="FileSystem的挂载和卸载">FileSystem的挂载和卸载</h5>
<p>  这里我们先举个例子，对于linux来说，内核启动后第一个挂载的文件系统，也就是挂载在/根目录的文件系统。如果大家观察过一些linux的启动相关信息，有个常见的问题就是：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">Error: root fs cannot be detected。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>  这个问题就是内核没有找到适合的根文件系统来加载，一般来说失败后会自动进入一个叫做initramfs的文件系统，方便进行诊断。</p>
<p>  对于用户挂载和卸载文件系统来说，一般我们是使用mount/umount命令，其和内核启动后挂载第一个文件系统的操作类似，其实我们执行mount命令的时候，对调用对应的file_system_type的mount函数（看上文中的file_system_type有一个mount函数）来完成挂载的操作。</p>
<p>  首先我们来看看mount命令是怎么到file_system_type中的mount函数的。我们来看看调用序列：</p>
<ol>
<li class="lvl-3">
<p>mount命令调用userspace 中的mount函数</p>
</li>
<li class="lvl-3">
<p>接着调用sys_mount</p>
</li>
<li class="lvl-3">
<p>接着调用do_mount</p>
</li>
<li class="lvl-3">
<p>接着调用path_mount</p>
</li>
<li class="lvl-3">
<p>接着调用do_new_mount，在这里我们会根据参数，获取或者创建struct file_system_type对象。(linux kernel v4.20.17)</p>
</li>
<li class="lvl-3">
<p>接着调用vfs_kern_mount。(linux kernel v4.20.17)</p>
</li>
<li class="lvl-3">
<p>接着调用mount_fs，在这里面通过struct file_system_type对象调用ext4_mount函数。(linux kernel v4.20.17)</p>
</li>
</ol>
<p>  上面的操作完毕， 我们得到一个struct vfsmount 和  struct mount 对象，这个对象代表了一个文件系统的挂载基本信息。struct mount 中的mnt_instance指向的是ext4 fs 的root dentry中的super_block存放的链表。意思就是，创建好的一个文件系统，其挂载点信息可以在root dentry中找到。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>mnt_root<span class="token punctuation">;</span>	<span class="token comment">/* root of the mounted tree */</span>
	<span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>mnt_sb<span class="token punctuation">;</span>	<span class="token comment">/* pointer to superblock */</span>
	<span class="token keyword">int</span> mnt_flags<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mnt_idmap</span> <span class="token operator">*</span>mnt_idmap<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span> __randomize_layout<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">mount</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">hlist_node</span> mnt_hash<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">mount</span> <span class="token operator">*</span>mnt_parent<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">dentry</span> <span class="token operator">*</span>mnt_mountpoint<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">vfsmount</span> mnt<span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span> mnt_instance<span class="token punctuation">;</span>	<span class="token comment">/* mount instance on sb->s_mounts */</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  下面我们来讲讲ext4的file_system_type定义中，ext4_mount的调用。</p>
<p>  注意，file_system_type的mount接口在新的内核版本中被废弃了，因为有新的mount api实现，所以在5.17-rc1中，ext4_mount这个函数无了。下面是linux kernel中这个提交的commit内容：</p>
<pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">ext4: switch to the new mount api
Add the necessary functions for the fs_context_operations. Convert and
rename ext4_remount() and ext4_fill_super() to ext4_get_tree() and
ext4_reconfigure() respectively and switch the ext4 to use the new api.

One user facing change is the fact that we no longer have access to the
entire string of mount options provided by mount(2) since the mount api
does not store it anywhere. As a result we can't print the options to
the log as we did in the past after the successful mount.

Signed-off-by: Lukas Czerner &lt;lczerner@redhat.com>
Reviewed-by: Carlos Maiolino &lt;cmaiolino@redhat.com>
Link: https://lore.kernel.org/r/20211027141857.33657-13-lczerner@redhat.com
Signed-off-by: Theodore Ts'o &lt;tytso@mit.edu>

commit-id:cebe85d570cf84804e848332d6721bc9e5300e07<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  下面，我们仍用ext4_mount的函数内容来讲解。对于挂载来说，一般会做如下操作(对于磁盘来说)：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>根据mount命令的参数，ext4_mount调用mount_bdev函数。</p>
</li>
<li class="lvl-2">
<p>根据mount_bdev函数的dev_name获取struct block_device对象。</p>
</li>
<li class="lvl-2">
<p>通过struct block_device对象，初始化并创建struct super_block对象，将对象放到super_blocks链表中。</p>
</li>
<li class="lvl-2">
<p>返回此文件系统对于的根dentry的引用（例如ext4fs: 根据block group0中的inode table[2]获取根节点，并创建dentry），这个时候我们就可以解析整个文件系统的所有文件目录了。</p>
</li>
</ul>
<p>  从上面的说明我们可以知道，一个struct super_block对象，代表一个挂载的文件系统。其定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">list_head</span>	s_list<span class="token punctuation">;</span>		<span class="token comment">/* Keep this first */</span>
	<span class="token class-name">dev_t</span>			s_dev<span class="token punctuation">;</span>		<span class="token comment">/* search index; _not_ kdev_t */</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">char</span>		s_blocksize_bits<span class="token punctuation">;</span>
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span>		s_blocksize<span class="token punctuation">;</span>
	<span class="token class-name">loff_t</span>			s_maxbytes<span class="token punctuation">;</span>	<span class="token comment">/* Max file size */</span>
	<span class="token keyword">struct</span> <span class="token class-name">file_system_type</span>	<span class="token operator">*</span>s_type<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">super_operations</span>	<span class="token operator">*</span>s_op<span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从上面的结构来看，最重要的就是s_op了，这个代表对一个文件系统的一些基本操作方法。此外，对于s_list来说，很明显的表达了struct super_block会被存储到一个链表里面，在linux里面，是存放在 static LIST_HEAD(super_blocks) 变量中的。</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">super_operations</span> <span class="token punctuation">&#123;</span>
   	<span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>alloc_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">super_block</span> <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>destroy_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>free_inode<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

   	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>dirty_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>write_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">writeback_control</span> <span class="token operator">*</span>wbc<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>drop_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>evict_inode<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">inode</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<h5 id="ext4的各种操作实现">ext4的各种操作实现</h5>
<p>  上面我们提到了struct super_operations、struct inode_operations、struct file_operations这三个重要的操作，对于挂载的ext4fs来说，其实现在ext4中实现，并对应赋值给对应的指针。他们定义分别如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> ext4_file_operations <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">.</span>llseek		<span class="token operator">=</span> ext4_llseek<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>read_iter	<span class="token operator">=</span> ext4_file_read_iter<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>write_iter	<span class="token operator">=</span> ext4_file_write_iter<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>iopoll		<span class="token operator">=</span> iocb_bio_iopoll<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> ext4_ioctl<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_COMPAT</span></span>
	<span class="token punctuation">.</span>compat_ioctl	<span class="token operator">=</span> ext4_compat_ioctl<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
	<span class="token punctuation">.</span>mmap		<span class="token operator">=</span> ext4_file_mmap<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>mmap_supported_flags <span class="token operator">=</span> MAP_SYNC<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>open		<span class="token operator">=</span> ext4_file_open<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>release	<span class="token operator">=</span> ext4_release_file<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>fsync		<span class="token operator">=</span> ext4_sync_file<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>get_unmapped_area <span class="token operator">=</span> thp_get_unmapped_area<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>splice_read	<span class="token operator">=</span> ext4_file_splice_read<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>splice_write	<span class="token operator">=</span> iter_file_splice_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>fallocate	<span class="token operator">=</span> ext4_fallocate<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">inode_operations</span> ext4_file_inode_operations <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">.</span>setattr	<span class="token operator">=</span> ext4_setattr<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>getattr	<span class="token operator">=</span> ext4_file_getattr<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>listxattr	<span class="token operator">=</span> ext4_listxattr<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>get_inode_acl	<span class="token operator">=</span> ext4_get_acl<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>set_acl	<span class="token operator">=</span> ext4_set_acl<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>fiemap		<span class="token operator">=</span> ext4_fiemap<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>fileattr_get	<span class="token operator">=</span> ext4_fileattr_get<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>fileattr_set	<span class="token operator">=</span> ext4_fileattr_set<span class="token punctuation">,</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>


<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">super_operations</span> ext4_sops <span class="token operator">=</span> <span class="token punctuation">&#123;</span>
	<span class="token punctuation">.</span>alloc_inode	<span class="token operator">=</span> ext4_alloc_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>free_inode	<span class="token operator">=</span> ext4_free_in_core_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>destroy_inode	<span class="token operator">=</span> ext4_destroy_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>write_inode	<span class="token operator">=</span> ext4_write_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>dirty_inode	<span class="token operator">=</span> ext4_dirty_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>drop_inode	<span class="token operator">=</span> ext4_drop_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>evict_inode	<span class="token operator">=</span> ext4_evict_inode<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>put_super	<span class="token operator">=</span> ext4_put_super<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>sync_fs	<span class="token operator">=</span> ext4_sync_fs<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>freeze_fs	<span class="token operator">=</span> ext4_freeze<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>unfreeze_fs	<span class="token operator">=</span> ext4_unfreeze<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>statfs		<span class="token operator">=</span> ext4_statfs<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>show_options	<span class="token operator">=</span> ext4_show_options<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>shutdown	<span class="token operator">=</span> ext4_shutdown<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">CONFIG_QUOTA</span></span>
	<span class="token punctuation">.</span>quota_read	<span class="token operator">=</span> ext4_quota_read<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>quota_write	<span class="token operator">=</span> ext4_quota_write<span class="token punctuation">,</span>
	<span class="token punctuation">.</span>get_dquots	<span class="token operator">=</span> ext4_get_dquots<span class="token punctuation">,</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从上面来，还没有挂载的时候，对于一个ext4fs的各种操作就已经实现了，挂载只是将这些操作实现对应赋值而已。</p>
<p>  这里多说一句，其他的fs也会有对应operations的实现。例如：我们常见的驱动开发的时候，file_operations的填充可以说是基操。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="总结">总结</h3>
<hr>
<p>  总的来说，vfs提供了对各种fs的操作的封装。mount命令可以将特定文件系统绑定到vfs。当我们mount一个fs时，可以得到这个fs的root dentry，super_block，mount等结构信息。</p>
<p>  我们根据一个fs的root dentry信息，可以解析出其目录下的所有文件目录结构，从而达到访问特定文件系统、特定设备的文件的目的。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/next/filesystems/vfs.html">https://www.kernel.org/doc/html/next/filesystems/vfs.html</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/04/27/blog_idx_130/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/27/blog_idx_130/" class="post-title-link" itemprop="url">Linux 文件系统(一) --- ext4文件系统简介</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-27 15:39:00" itemprop="dateCreated datePublished" datetime="2024-04-27T15:39:00+08:00">2024-04-27</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-18 19:06:02" itemprop="dateModified" datetime="2024-05-18T19:06:02+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.2k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>15 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=130） 
&emsp;&emsp;本文发布于 2024-04-27 15:39:00             （BlogID=130） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  在linux下面，常见的linux fs就是ext系列，linux里面的vfs也和这个ext fs息息相关。本文主要详解一下ext4 fs的实现原理，并且，从文件操作的角度来看，ext4 fs是怎么实现这一系列工作的。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="一些基本知识">一些基本知识</h3>
<hr>
<p>  常见的硬盘有两种类别：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>传统硬盘（HDD，Hard Disk Drive）</p>
</li>
<li class="lvl-2">
<p>固态硬盘（SSD，Solid State Drive）</p>
</li>
</ul>
<p>  其实稍微对硬盘有一点了解的人都知道，这两者硬盘的结构和原理是完全不一样的（具体可看很多网上的相关资料）。</p>
<p>  对于HDD来说，其是有磁头、盘片、马达等构成，盘片概念中又可以得到扇区、柱面的概念。根据这些物理的技术事实，引出了CHS（柱面数（Cylinders）、磁头数（Headers）、扇区数（Sectors））寻址方式。后面经过发展，又有了LBA（Logic Block Address）寻址方式（具体可看很多网上的相关资料））。</p>
<br/>
<br/>
<h5 id="格式化">格式化</h5>
<p>  这里的格式化有两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>低级格式化</p>
</li>
<li class="lvl-2">
<p>高级格式化</p>
</li>
</ul>
<p>  对于低级格式化来说，一般是硬盘厂家格式化好的，对磁盘的一些基本参数进行设置。</p>
<p>  对于高级格式化来说，这就是我们用户普遍开始接触使用硬盘的第一步，我们后续解释ext的文件系统，也是基本是高级格式化来完成的。</p>
<br/>
<br/>
<h5 id="扇区介绍">扇区介绍</h5>
<p>  对于上层用户来说， 描述一个磁盘的相关属性使用扇区来描述，一个扇区一般是512字节，磁盘总容量是扇区数*512字节。</p>
<br/>
<br/>
<h5 id="什么是文件系统？">什么是文件系统？</h5>
<p>  文件系统是指通过什么样的结构来组织数据的存储方式。具体来说，就是怎么对某一个文件进行定位和操作。一个基本的fs例子可以参考以前我写的关于FAT文件系统的组织方式（《FAT32 文件系统详解》 <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011728480/article/details/58049184%EF%BC%89%E3%80%82">https://blog.csdn.net/u011728480/article/details/58049184）。</a></p>
<br/>
<br/>
<br/>
<br/>
<h3 id="EXT4文件系统的组织方式">EXT4文件系统的组织方式</h3>
<hr>
<br/>
<br/>
<h5 id="ext4-fs的简介与宏观结构">ext4 fs的简介与宏观结构</h5>
<p>  ext4 fs的基本存储单位是block，一个block可能由多个扇区组成，对于ext4来说，其有以下的一些基本属性：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>一个block的大小可能是：1k-64k，并且其扇区的个数必须是2的指数，其大小是由mkfs来确定的。</p>
</li>
<li class="lvl-2">
<p>多个block可以组成一个更大的单位，叫做block group。</p>
</li>
<li class="lvl-2">
<p>一般情况下，一个文件系统可以最多有2<sup>32个block。如果ext4文件系统启用了64位的特性，那么其最多可以有2</sup>64个block。</p>
</li>
</ul>
<p>  从上面可以知道ext4 fs可以描述的磁盘容量大小和我们创建文件系统时的参数有关，有兴趣可以去看参考小节的文档。</p>
<p>  ext4 fs的宏观结构如下：</p>
<table>
<thead>
<tr>
<th>block group 0</th>
<th>block group 1</th>
<th>… …</th>
<th>block group n-1</th>
<th>block group n</th>
</tr>
</thead>
</table>
<p>  对于block group 0 来说：</p>
<table>
<thead>
<tr>
<th>Group 0 Padding</th>
<th>ext4 Super Block</th>
<th>Group Descriptors</th>
<th>Reserved GDT Blocks</th>
<th>Data Block Bitmap</th>
<th>inode Bitmap</th>
<th>inode Table</th>
<th>Data Blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1024 bytes</td>
<td>1 block</td>
<td>many blocks</td>
<td>many blocks</td>
<td>1 block</td>
<td>1 block</td>
<td>many blocks</td>
<td>many more blocks</td>
</tr>
</tbody>
</table>
<p>  对于block group n(n != 0) 来说：</p>
<table>
<thead>
<tr>
<th>ext4 Super Block（可选）</th>
<th>Group Descriptors（可选）</th>
<th>Reserved GDT Blocks（可选）</th>
<th>Data Block Bitmap</th>
<th>inode Bitmap</th>
<th>inode Table</th>
<th>Data Blocks</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 block</td>
<td>many blocks</td>
<td>many blocks</td>
<td>1 block</td>
<td>1 block</td>
<td>many blocks</td>
<td>many more blocks</td>
</tr>
</tbody>
</table>
<p>  从上面的三个表格可以知道，ext4fs是由多个block group构成，其中block group0有一个1k的填充部分，这部分主要是兼容以前老旧的引导分区使用。其他block group并没有这1k的填充部分。</p>
<p>  下面我们分别详解block group中的具体每个部分是什么内容，以block_size是4k为例。</p>
<br/>
<br/>
<h5 id="ext4-Super-Block">ext4 Super Block</h5>
<p>  我们先来看看fs/ext4/ext4.h里面定义的内容：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Structure of the super block
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_super_block</span> <span class="token punctuation">&#123;</span>
    __le32	s_inodes_count<span class="token punctuation">;</span>		<span class="token comment">/* Inodes count */</span>
	__le32	s_blocks_count_lo<span class="token punctuation">;</span>	<span class="token comment">/* Blocks count */</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    __le32	s_log_block_size<span class="token punctuation">;</span>	<span class="token comment">/* Block size */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    __le32	s_blocks_per_group<span class="token punctuation">;</span>	<span class="token comment">/* # Blocks per group */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从这个定义可以看出，ext4_super_block 包含了很多ext4 fs的meta信息，例如：inode个数，blocks个数，block大小，每个组里面的block大小。我们可以使用dumpfs命令来查看superblock的信息，如下：</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_130/super_block.png" alt="rep_img"/></center>
    </div>
</div>    
<p>  注意看，对于block group n(n != 0)来说，ext4 Super Block、Group Descriptors等重要的结构是可选的，这里就涉及到ext的另外一个概念，通过备份这些重要的数据结构在不同的block group中，当block group 0数据损坏时，可以从其他分区尝试恢复。</p>
<br/>
<br/>
<h5 id="Group-Descriptors">Group Descriptors</h5>
<p>  组描述符是一个数据结构，其数据是第二个block开始，其定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * Structure of a blocks group descriptor
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_group_desc</span>
<span class="token punctuation">&#123;</span>
	__le32	bg_block_bitmap_lo<span class="token punctuation">;</span>	<span class="token comment">/* Blocks bitmap block */</span>
	__le32	bg_inode_bitmap_lo<span class="token punctuation">;</span>	<span class="token comment">/* Inodes bitmap block */</span>
	__le32	bg_inode_table_lo<span class="token punctuation">;</span>	<span class="token comment">/* Inodes table block */</span>
	__le16	bg_free_blocks_count_lo<span class="token punctuation">;</span><span class="token comment">/* Free blocks count */</span>
	__le16	bg_free_inodes_count_lo<span class="token punctuation">;</span><span class="token comment">/* Free inodes count */</span>
	__le16	bg_used_dirs_count_lo<span class="token punctuation">;</span>	<span class="token comment">/* Directories count */</span>
	__le16	bg_flags<span class="token punctuation">;</span>		<span class="token comment">/* EXT4_BG_flags (INODE_UNINIT, etc) */</span>
	__le32  bg_exclude_bitmap_lo<span class="token punctuation">;</span>   <span class="token comment">/* Exclude bitmap for snapshots */</span>
	__le16  bg_block_bitmap_csum_lo<span class="token punctuation">;</span><span class="token comment">/* crc32c(s_uuid+grp_num+bbitmap) LE */</span>
	__le16  bg_inode_bitmap_csum_lo<span class="token punctuation">;</span><span class="token comment">/* crc32c(s_uuid+grp_num+ibitmap) LE */</span>
	__le16  bg_itable_unused_lo<span class="token punctuation">;</span>	<span class="token comment">/* Unused inodes count */</span>
	__le16  bg_checksum<span class="token punctuation">;</span>		<span class="token comment">/* crc16(sb_uuid+group+desc) */</span>
	__le32	bg_block_bitmap_hi<span class="token punctuation">;</span>	<span class="token comment">/* Blocks bitmap block MSB */</span>
	__le32	bg_inode_bitmap_hi<span class="token punctuation">;</span>	<span class="token comment">/* Inodes bitmap block MSB */</span>
	__le32	bg_inode_table_hi<span class="token punctuation">;</span>	<span class="token comment">/* Inodes table block MSB */</span>
	__le16	bg_free_blocks_count_hi<span class="token punctuation">;</span><span class="token comment">/* Free blocks count MSB */</span>
	__le16	bg_free_inodes_count_hi<span class="token punctuation">;</span><span class="token comment">/* Free inodes count MSB */</span>
	__le16	bg_used_dirs_count_hi<span class="token punctuation">;</span>	<span class="token comment">/* Directories count MSB */</span>
	__le16  bg_itable_unused_hi<span class="token punctuation">;</span>    <span class="token comment">/* Unused inodes count MSB */</span>
	__le32  bg_exclude_bitmap_hi<span class="token punctuation">;</span>   <span class="token comment">/* Exclude bitmap block MSB */</span>
	__le16  bg_block_bitmap_csum_hi<span class="token punctuation">;</span><span class="token comment">/* crc32c(s_uuid+grp_num+bbitmap) BE */</span>
	__le16  bg_inode_bitmap_csum_hi<span class="token punctuation">;</span><span class="token comment">/* crc32c(s_uuid+grp_num+ibitmap) BE */</span>
	__u32   bg_reserved<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  其实从这里可以看到，根据组描述符，我们可以知道后面三个重要的区块（Data Block Bitmap/inode Bitmap/inode Table）的block号，也就定位到这3个重要的区块了。</p>
<p>  但是这里有一个问题是需要我们处理的，就是组描述符是一个数组，它描述了多个block group，那么我们怎么知道有多少个组描述呢？那就是直接用superblock里面的s_blocks_count_lo/s_blocks_per_group就得到了有多个group descriptor。</p>
<p>  同理，我们可以使用dumpfs命令来查看group descriptor 0的信息(block group 0)，如下：</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_130/group_descriptor0.png" alt="rep_img"/></center>
    </div>
</div>    
<p>  注意，上面的Reserved GDT Blocks是用做以后扩充group descriptor使用的（也就是扩充extfs容量）。</p>
<br/>
<br/>
<h5 id="Data-Block-Bitmap">Data Block Bitmap</h5>
<p>  data block bitmap主要就是使用bitmap描述data block的使用情况。其起始位置是group descriptor中的bg_block_bitmap_lo来确定的。</p>
<p>  以block_size是4k为例，那么我们能够通过bitmap来描述的block个数为：4 * 1024 * 8 = 32768，通过上面的知识可以看到，恰好对应一个block group的大小。</p>
<br/>
<br/>
<h5 id="inode-Bitmap">inode Bitmap</h5>
<p>  inode bitmap和data block bitmap类似，用于描述inode的使用情况。其起始位置是group descriptor中的bg_inode_bitmap_lo来确定的。后面我们会关联到这个地方的知识点。</p>
<p>  以block_size是4k为例，同上，我们最多只能有32768个inode。</p>
<p>  这里提到的inode概念可以先不管，你可以把一个inode当做一个文件的抽象概念来处理。inode这个概念在linux vfs和ext4 fs都会使用到，而且是相互关联的。</p>
<br/>
<br/>
<h5 id="inode-Table">inode Table</h5>
<p>  inode Table 是由一个个ext4_inode组成的数组。ext4_inode定义如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c">
<span class="token comment">/*
 * Structure of an inode on the disk
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_inode</span> <span class="token punctuation">&#123;</span>

    __le16	i_mode<span class="token punctuation">;</span>		<span class="token comment">/* File mode */</span>
	__le16	i_uid<span class="token punctuation">;</span>		<span class="token comment">/* Low 16 bits of Owner Uid */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

    __le32	i_blocks_lo<span class="token punctuation">;</span>	<span class="token comment">/* Blocks count */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 

    __le32	i_block<span class="token punctuation">[</span>EXT4_N_BLOCKS<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">/* Pointers to blocks */</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> 
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从上面可以简单知道，这里有一个文件的属性、大小、数据block的指针等等。ext4_inode可以描述一个文件的基本信息，这个结构将会在本系列文章中的vfs里面介绍。linux提供了stat命令来获取这个结构的信息，例如下图：</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_130/stat.png" alt="rep_img"/></center>
    </div>
</div>    
<p>  从图中可知，我们可以知道inode的序号、inode包含的blocks的个数，以及文件其他属性等等。</p>
<p>  此外根据其数据结构可以知道，ext4_inode的文件大小上限由EXT4_N_BLOCKS=15个block决定，从理论上来说，如果大于这个尺寸的ext采取的是通过类似间接寻址的方式。对于ext4 fs来说，对这个间接寻址做了详细介绍，下面我们对这种间接寻址做一点简单说明（以block_size=4k为例）：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>ext4_inode.i_block数组中的0~11数据块，直接填写到这个数组。到这里，我们支持的最大文件大小为12 * block_size。</p>
</li>
<li class="lvl-2">
<p>当文件大小大于12 * block_size时，那么启用一级映射，ext4_inode.i_block数组的第12个指向的数据块是一个索引数据块，其包含了真实文件数据的block的索引。对于block_size=4k来说，那么可以间接映射block_size/sizeof(__le32)=1024个block。到这里，我们支持的最大文件大小为(12 + block_size/4) * block_size。</p>
</li>
<li class="lvl-2">
<p>当文件大小大于(12 + block_size/4) * block_size，启用二级映射，ext4_inode.i_block数组的第13个指向的数据块是一级映射数据块，后面规则和一级映射一致。到这里，我们支持的最大文件大小为(12 + block_size/4 + (block_size/4)^2 ) * block_size。</p>
</li>
<li class="lvl-2">
<p>当文件大小大于(12 + block_size/4 + (block_size/4)^2 ) * block_size，启用三级映射，ext4_inode.i_block数组的第14个指向的数据块是二级映射数据块，后面规则和二级映射一致。到这里，我们支持的最大文件大小为(12 + block_size/4 + (block_size/4)^2  + (block_size/4)^3) * block_size。</p>
</li>
</ul>
<p>  其实从上面来看，如果我们存储和访问一个大文件，由于机制的原因，效率是非常底下的，因此ext4 fs里面有一个flex_bg特性，可以用更高效的extent tree数据结构来描述大文件。本文不对这个做介绍。</p>
<p>  此外，ext4 fs预留了一些特殊inode的编号，他们如下图表格：</p>
<table>
<thead>
<tr>
<th>inode Number</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Doesn’t exist; there is no inode 0.</td>
</tr>
<tr>
<td>1</td>
<td>List of defective blocks.</td>
</tr>
<tr>
<td>2</td>
<td>Root directory.</td>
</tr>
<tr>
<td>3</td>
<td>User quota.</td>
</tr>
<tr>
<td>4</td>
<td>Group quota.</td>
</tr>
<tr>
<td>5</td>
<td>Boot loader.</td>
</tr>
<tr>
<td>6</td>
<td>Undelete directory.</td>
</tr>
<tr>
<td>7</td>
<td>Reserved group descriptors inode. (“resize inode”)</td>
</tr>
<tr>
<td>8</td>
<td>Journal inode.</td>
</tr>
</tbody>
</table>
<p>  这里面对我们来说，最有用的就是inode=2的inode节点，它是代表这个文件系统的根目录。这个根目录在vfs挂载文件系统的时候，有重要作用。</p>
<p>  对于多个block group来说，其每个inode Table大小是一定的，这个在super block里面就定义了，例如上文图中“Inodes per group:8192”代表每个block group有8192个inode。当我们mkfs.ext4时，inode的数量是固定了，我们可以修改这个参数来适应一些特殊情况，例如：inode满了，但是磁盘空间没有占满，这个是属于优化项了，这里不做讨论。如下图，df -i可以查看fs的inode使用信息，df -h是fs的磁盘容量信息：</p>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_130/df0.png" alt="rep_img"/></center>
    </div>
</div>  
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/blog_idx_130/df1.png" alt="rep_img"/></center>
    </div>
</div>  
<p>  从图中的根目录分区来看，他们的inode占用和容量占用完全不一致，如图来说，可能是容量用完了，但是inode没有用完，可是有另外一种情况，那就是容量没有用完，inode用完了，一般出现在存放很多小文件的ext4fs。</p>
<p>  这里还有一个重要的信息，我们知道有多个block group，且每个block group一定有Data Block Bitmap、inode Bitmap、inode Table。其中有一个很重要的概念就是每个block group的inode Table里面的inode序号是连续的。</p>
<br/>
<br/>
<h5 id="Data-Blocks">Data Blocks</h5>
<p>  data blocks就是文件的真实数据块，由ext4_inode来指定。</p>
<br/>
<br/>
<h5 id="目录">目录</h5>
<p>  就上面我们描述的内容来看，我们可以通过一个inode来描述一个文件了，但是还有一类我们常见的类型：目录，却没有提到。</p>
<p>  其实对于文件系统来说，目录也是文件，也是通过inode来描述的，在上文，其实我们提到了inode=2的indoe节点，它就是根目录项，也是解析ext4fs的起点。</p>
<p>  传统来说，对于目录的inode，其指向的block是基于目录项的数组（新的ext4 fs还有hash目录，其在ext3 引入，可以提升目录操作性能, 本文不做介绍），一个对于目录项来说，有两个结构：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry</span> <span class="token punctuation">&#123;</span>
	__le32	inode<span class="token punctuation">;</span>			<span class="token comment">/* Inode number */</span>
	__le16	rec_len<span class="token punctuation">;</span>		<span class="token comment">/* Directory entry length */</span>
	__le16	name_len<span class="token punctuation">;</span>		<span class="token comment">/* Name length */</span>
	<span class="token keyword">char</span>	name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* File name */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/*
 * The new version of the directory entry.  Since EXT4 structures are
 * stored in intel byte order, and the name_len field could never be
 * bigger than 255 chars, it's safe to reclaim the extra byte for the
 * file_type field.
 */</span>
<span class="token keyword">struct</span> <span class="token class-name">ext4_dir_entry_2</span> <span class="token punctuation">&#123;</span>
	__le32	inode<span class="token punctuation">;</span>			<span class="token comment">/* Inode number */</span>
	__le16	rec_len<span class="token punctuation">;</span>		<span class="token comment">/* Directory entry length */</span>
	__u8	name_len<span class="token punctuation">;</span>		<span class="token comment">/* Name length */</span>
	__u8	file_type<span class="token punctuation">;</span>		<span class="token comment">/* See file type macros EXT4_FT_* below */</span>
	<span class="token keyword">char</span>	name<span class="token punctuation">[</span>EXT4_NAME_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span>	<span class="token comment">/* File name */</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  对于我们常用的ext4fs系统来说，启用了filetype这个特性，就是用的ext4_dir_entry_2这个结构。注意这个结构和linux用户态的struct dirent有直接关联，后面有缘可以介绍一下rewinddir/readdir等接口的使用。</p>
<p>  对于目录项来说，除了inode序号外，最重要的就是file_type信息了，他们的典型值如下：</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0x0</td>
<td>Unknown.</td>
</tr>
<tr>
<td>0x1</td>
<td>Regular file.</td>
</tr>
<tr>
<td>0x2</td>
<td>Directory.</td>
</tr>
<tr>
<td>0x3</td>
<td>Character device file.</td>
</tr>
<tr>
<td>0x4</td>
<td>Block device file.</td>
</tr>
<tr>
<td>0x5</td>
<td>FIFO.</td>
</tr>
<tr>
<td>0x6</td>
<td>Socket.</td>
</tr>
<tr>
<td>0x7</td>
<td>Symbolic link.</td>
</tr>
</tbody>
</table>
<p>  这里面最重要的type就是1和2，一个代表普通文件，一个代表目录。</p>
<p>  有了这个数据结构介绍，我们就介绍完了ext4fs的基本组织形式，下面我们通过文件的基本操作来整体感受一下这种组织方式。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="文件的操作与文件系统的组织方式">文件的操作与文件系统的组织方式</h3>
<hr>
<p>  其实这里的文件操作与vfs有关联，但是现在我们就当做没有vfs。如果有上面基础的情况下，我们怎么写一个驱动来在ext4fs上操作文件。后面都是一些直白想法，要了解具体细节，移步本文后续系列，关于VFS的一点点资料。</p>
<p>  对于文件的操作来说，我们第一步要定位这个文件。如果要定位这个文件，那么我们就需要这个文件的绝对路径。下面对于文本文件：/tmp/test.lg，我们看看怎么定位它：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>首先根据ext4 Super Block得到Group Descriptors的属性，然后得到block group0 的 Group Descriptors的属性，最后得到block group0 的inode table/inode bitmap/data blocks bitmap。</p>
</li>
<li class="lvl-2">
<p>根据block group0中的inode table[2]得到这个文件系统根目录的数据块，然后根据ext4_dir_entry_2来递归的解析出ext4fs的所有文件目录树。</p>
</li>
<li class="lvl-2">
<p>根据/tmp/test.lg文件的绝对路径信息，结合上面我们的文件目录树，我们首先解析了&quot;/&quot;的目录项数组，得到了tmp目录的目录inode信息。然后根据tmp目录的目录项数组，得到了test.lg的inode信息。到这里，我们成功得到了文件的inode序号。</p>
</li>
<li class="lvl-2">
<p>根据得到的inode序号，做相关的操作（读、写、创建、删除）。</p>
</li>
</ul>
<p>  其实上面我们操作一个文件的过程，在真正的linux系统中，由vfs和ext4fs驱动帮我们做了大量工作，具体我们到时候在vfs文章中来做一个文件操作的介绍。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  从本文和本人之前的文章中关于FAT文件系统的介绍来看，其实文件系统的核心在于：给定一个存储的介质，在这个存储介质上是怎么存放文件的，比如建议分组，建立映射等等。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://www.kernel.org/doc/html/v4.19/filesystems/ext4/ondisk/index.html">https://www.kernel.org/doc/html/v4.19/filesystems/ext4/ondisk/index.html</a></p>
</li>
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/u011728480/article/details/58049184">https://blog.csdn.net/u011728480/article/details/58049184</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/04/21/blog_idx_129/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/04/21/blog_idx_129/" class="post-title-link" itemprop="url">Linux_aarch64_head.S到main.c的环境建立</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-04-21 16:56:00" itemprop="dateCreated datePublished" datetime="2024-04-21T16:56:00+08:00">2024-04-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-18 19:06:02" itemprop="dateModified" datetime="2024-05-18T19:06:02+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/%E5%B5%8C%E5%85%A5%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">嵌入式</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/%E5%B5%8C%E5%85%A5%E5%BC%8F/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7.5k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>27 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=129） 
&emsp;&emsp;本文发布于 2024-04-21 16:56:00             （BlogID=129） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  最开始，我仅仅是对linux比较感兴趣，觉得其很神奇的，能够做到很多事情。后面了解到其源码也是开源的，于是抱着学习的态度，简要的看了看相关的代码，在那个时候，我还看的比较粗略，仅仅是简单的会点编译，执行linux命令等等。这期间还有一个有印象的有趣的事儿就是那个pdf《Linux 那些事儿之USB》，大概就是讲述了作者因为要看pian儿，但是U盘识别不到，所以去细读USB相关linux 内核内容的资料。这精神，虽然我看不懂，但是我大为震撼！！！</p>
<p>  在我工作的近几年来，逐渐的和linux打上了交道，从最开始的hisi 3520a<a href="#refer-anchor-1"><sup>1</sup></a>系列的流媒体处理开始，为其搭建了文件系统，编译内核，同时为其适配EC20 4G模块，这期间，我基本都是照着别人的教程或者说文档，渐渐的熟悉了一些linux内核的一些事务。同时这期间，我做过一些简单的字符驱动玩耍模块，只能说玩玩可以的。</p>
<p>  在前几年中的某段时间，我接到一个任务，要在android进程之间大量传输数据<a href="#refer-anchor-2"><sup>2</sup></a>。这个时候我调研到了一个叫做android 匿名共享内存的东西，我发现了一个binder的驱动程序和linux unix socket的功能可以在android 和 linux 里面实现进程间的文件描述符的共享，注意这个方法是通用的，不像某些功能在linux里面能够使用，在android里面不能够使用。在这个时候，我天马行空实现了一个类似 binder的驱动demo<a href="#refer-anchor-3"><sup>3</sup></a>。这可以说是我第一个为了自己写的内核及的相关代码，而且具有实际应用意义。</p>
<p>  在这些工作过程中，我逐渐的觉得自己学习的《操作系统原理》与现实的差别，特别想把书中知识和实际系统结合起来，经过查询，如果想要大概了解linux 内核，最好从其远古的版本读起来，因为大概的脉络没有变，新内核只是更加的结构化，多了很多现代的功能。于是乎，有了《Linux Kernel 0.12 启动简介，调试记录(Ubuntu1804, Bochs, gdb)》一文<a href="#refer-anchor-4"><sup>4</sup></a>。经过了《Linux Kernel 0.12 启动简介，调试记录(Ubuntu1804, Bochs, gdb)》一文的学习之后，我基本了解了linux kernel 0.12版本内核的基本工作原理，例如其调度，内存管理等。其次是对于x86架构下，linux kernel 0.12的启动流程有了一个简要的认知。</p>
<p>  在最近这段时间，我的工作有部分和ai相关，有部分和android和linux的差异相关，需要我对linux内核有更深的印象和见解。于是在以前的基础上，这次，我要实际分析我们工作中所用的最新版本的内核，再一次的去验证一个内核从上电开始，到系统完整起来的过程。由于现代linux内核非常的巨大，所以我只关注我喜欢的部分。</p>
<p>  本文主要是分析aarch64架构的arch/arm64/kernel/head.S 到 init/main.c 中的start_kernel的过程。这可能也是我短时间内最后一次分析这种启动的过程，因为其实道理都是相同的，大部分都是cpu初始化，虚拟内存启用，由实地址切换为虚拟地址，创建init_task，设置sp，进入start_kernel。其实这里很多都是和特定的CPU有关系，内容是固定的。但是虚拟内存启用，初始task创建，初始sp指针初始化这些和《操作系统原理》有关联，可以印证我们所学。</p>
<p>  本文分为两大部分，一部分是head.S到main.c的调试环境建立， 二是从上电开始到进入start_kernel的代码注释分析和部分解释。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="准备">准备</h3>
<hr>
<ol>
<li class="lvl-3">
<p>AARCH64 异常等级要简单了解一下<a href="#refer-anchor-5"><sup>5</sup></a>。</p>
</li>
<li class="lvl-3">
<p>AARCH64 内存布局要简单了解一下<a href="#refer-anchor-6"><sup>6</sup></a>。</p>
</li>
<li class="lvl-3">
<p>看长文警告，一定要有耐心，否则看不下去。</p>
</li>
</ol>
<h3 id="汇编部分的调试环境搭建">汇编部分的调试环境搭建</h3>
<hr>
<p>  本文的测试环境为qemu-system-aarch64 raspi3b 模拟板卡。linux内核为树莓派内核 rpi-5.15.y， 下载地址为：<a target="_blank" rel="noopener" href="https://github.com/raspberrypi/linux.git">https://github.com/raspberrypi/linux.git</a></p>
<br/>
<br/>
<h5 id="生成带调试符号的linux-kernel-镜像">生成带调试符号的linux kernel 镜像</h5>
<p>  在make menu的时候勾选： Kernel hacking &gt; Compile-time checks and compiler options &gt; Compile the kernel with debug info<br>
通过如下命令生成镜像：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> rpi-linux-kernel-dir
<span class="token function">cp</span> arch/arm64/configs/bcm2711_defconfig .config
<span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64 <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu- menuconfig
<span class="token function">make</span> <span class="token assign-left variable">ARCH</span><span class="token operator">=</span>arm64 <span class="token assign-left variable">CROSS_COMPILE</span><span class="token operator">=</span>aarch64-linux-gnu- Image modules dtbs
``<span class="token variable"><span class="token variable">`</span>   

<span class="token operator">&lt;</span>br/<span class="token operator">></span>
<span class="token operator">&lt;</span>br/<span class="token operator">></span>

<span class="token comment">##### 生成rootfs.img镜像</span>
<span class="token operator">&amp;</span>emsp<span class="token punctuation">;</span><span class="token operator">&amp;</span>emsp<span class="token punctuation">;</span>下载ubuntu-base-18.04.5-base-arm64.tar.gz的基础文件系统。
<span class="token variable">`</span></span>``shell
<span class="token comment"># 解压文件系统到指定目录</span>
<span class="token function">tar</span> <span class="token parameter variable">-xzf</span> ubuntu-base-18.04.5-base-arm64.tar.gz <span class="token parameter variable">-C</span> temp/*

<span class="token comment"># 制作裸文件镜像</span>
<span class="token function">dd</span> <span class="token assign-left variable">if</span><span class="token operator">=</span>/dev/zero <span class="token assign-left variable">of</span><span class="token operator">=</span>linuxroot.img <span class="token assign-left variable">bs</span><span class="token operator">=</span>1M <span class="token assign-left variable">count</span><span class="token operator">=</span><span class="token number">2048</span>
<span class="token function">sudo</span> mkfs.ext4 linuxroot.img
<span class="token function">mkdir</span>  rootfs
<span class="token function">sudo</span> <span class="token function">mount</span> linuxroot.img rootfs/
<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-rfp</span> temp/*  rootfs/
<span class="token function">sudo</span> <span class="token function">umount</span> rootfs/
e2fsck <span class="token parameter variable">-p</span> <span class="token parameter variable">-f</span> linuxroot.img
resize2fs  <span class="token parameter variable">-M</span> linuxroot.img<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h5 id="编译生成最新版qemu">编译生成最新版qemu</h5>
<p>  只有新版的qemu才支持raspi3b模拟板卡</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 下载qemu代码</span>
<span class="token function">git</span> clone https://github.com/qemu/qemu.git
<span class="token builtin class-name">cd</span> qemu
<span class="token function">mkdir</span> build
<span class="token builtin class-name">cd</span> build
<span class="token punctuation">..</span>/configure <span class="token parameter variable">--prefix</span><span class="token operator">=</span>/home/sky/LinuxKernel/qemu_install --target-list<span class="token operator">=</span>arm-softmmu,arm-linux-user,armeb-linux-user,aarch64-softmmu,aarch64-linux-user,aarch64_be-linux-user 
<span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<h5 id="执行qemu加载镜像">执行qemu加载镜像</h5>
<p>  这里的linux目录是内核目录，qemu_install是qemu生成的最新可执行文件目录，当前目录有rootfs镜像linuxroot.img。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># -S              freeze CPU at startup (use 'c' to start execution)</span>
<span class="token comment"># -s              shorthand for -gdb tcp::1234</span>
<span class="token comment">#  注意下面命令如果要直接运行，而不是等待gdb调试，请去掉最后的-s 和 -S。</span>
./qemu_install/bin/qemu-system-aarch64 <span class="token punctuation">\</span>
	<span class="token parameter variable">-M</span> raspi3b <span class="token punctuation">\</span>
	<span class="token parameter variable">-kernel</span> ./linux/arch/arm64/boot/Image <span class="token punctuation">\</span>
	<span class="token parameter variable">-dtb</span> ./linux/arch/arm64/boot/dts/broadcom/bcm2710-rpi-3-b.dtb <span class="token punctuation">\</span>
	<span class="token parameter variable">-drive</span> <span class="token assign-left variable">id</span><span class="token operator">=</span>hd-root,format<span class="token operator">=</span>raw,file<span class="token operator">=</span>./linuxroot.img <span class="token punctuation">\</span>
	<span class="token parameter variable">-m</span> 1024M <span class="token punctuation">\</span>
	<span class="token parameter variable">-serial</span> stdio <span class="token punctuation">\</span>
	<span class="token parameter variable">-smp</span> <span class="token number">4</span> <span class="token punctuation">\</span>
	<span class="token parameter variable">-device</span> usb-kbd <span class="token punctuation">\</span>
	<span class="token parameter variable">-device</span> usb-tablet <span class="token punctuation">\</span>
	<span class="token parameter variable">-device</span> usb-net,netdev<span class="token operator">=</span>net0 <span class="token punctuation">\</span>
	<span class="token parameter variable">-netdev</span> user,id<span class="token operator">=</span>net0,hostfwd<span class="token operator">=</span>tcp::5555-:22 <span class="token punctuation">\</span>
	<span class="token parameter variable">-append</span> <span class="token string">"rw earlycon=pl011,0x3f201000 console=ttyAMA0 loglevel=8 root=/dev/mmcblk0 rootwait"</span> <span class="token parameter variable">-S</span> <span class="token parameter variable">-s</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<h5 id="gdb-连接调试">gdb 连接调试</h5>
<p>  注意请在qemu启动后面加上-s 和 -S。当连接成功时，这个时候cpu还未执行，输入ni执行到第一条指令。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 没有gdb-multiarch自行安装</span>
<span class="token comment"># 这里的vmlinux就是编译生成的最终镜像</span>
gdb-multiarch  linux/vmlinux

<span class="token comment"># 在gdb cli中执行</span>
target remote localhost:1234<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<br/>
<br/>
<h5 id="汇编代码调试">汇编代码调试</h5>
<p>  我这里把整个head.S里面重要的部分都dump下来了。跟着这个部分然后参考head.S去阅读，会有奇效。长文注释警告。</p>
<p>  首先是上电部分，当板卡上电后，会执行bootloader，bootloader会将内核和dtb放到特定的位置，然后按照Linux arm64 boot protocal去初始化对应的寄存器，最后进入head.S的第一条指令。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ boot start ... ...
&#x2F;&#x2F;Linux arm64 boot protocal
@ https:&#x2F;&#x2F;www.kernel.org&#x2F;doc&#x2F;Documentation&#x2F;arm64&#x2F;booting.txt
@ 0x08000000 FDT
&#x2F;*
- 主 CPU 通用寄存器设置
  x0 &#x3D; 系统 RAM 中设备树 blob (dtb) 的物理地址。
  x1 &#x3D; 0（留作将来使用）
  x2 &#x3D; 0（留作将来使用）
  x3 &#x3D; 0（留作将来使用）
*&#x2F;
&#x2F;&#x2F;注意这里的0x18地址存放的是fdt的地址，地址为0x08000000

0x0000000000000000:	ldr	x0, 0x18
0x0000000000000004:	mov	x1, xzr
0x0000000000000008:	mov	x2, xzr
0x000000000000000c:	mov	x3, xzr
&#x2F;&#x2F;注意这里的0x20是存放的kernel地址，地址为0x00200000
0x0000000000000010:	ldr	x4, 0x20
0x0000000000000014:	br	x4
@ 0x00200000 head.S start ... ...
@ &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; now, go to 0x00200000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  注意，当我们进入head.S的最开始的地方的时候，有一个标准得到头如下。其中code1的部分将会跳转到真正执行的地方。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ The decompressed kernel image contains a 64-byte header as follows:
@   u32 code0;			&#x2F;* Executable code *&#x2F; 
@   u32 code1;			&#x2F;* Executable code *&#x2F;
@   u64 text_offset;		&#x2F;* Image load offset, little endian *&#x2F;
@   u64 image_size;		&#x2F;* Effective Image size, little endian *&#x2F;
@   u64 flags;			&#x2F;* kernel flags, little endian *&#x2F;
@   u64 res2	&#x3D; 0;		&#x2F;* reserved *&#x2F;
@   u64 res3	&#x3D; 0;		&#x2F;* reserved *&#x2F;
@   u64 res4	&#x3D; 0;		&#x2F;* reserved *&#x2F;
@   u32 magic	&#x3D; 0x644d5241;	&#x2F;* Magic number, little endian, &quot;ARM\x64&quot; *&#x2F;
@   u32 res5;			&#x2F;* reserved (used for PE COFF offset) *&#x2F;

@ 0x200000  code0
@ 0x200004  code1                            
@ 0x200008  text_offset 
@ 0x20000c                           
@ 0x200010  image_size                    
@ 0x200014                    
@ 0x200018  flags                       
@ 0x20001c                          
@ 0x200020  res2                    
@ 0x200024                          
@ 0x200028  res3                       
@ 0x20002c                      
@ 0x200030  res4                       
@ 0x200034                    
@ 0x200038  magic       
@ 0x20003c  res5
&#x2F;&#x2F;注意，这里的code0,code1就是地址0x200000和0x200004的指令。整个0x200000到0x200040就是内核镜像的64字节头。
0x0000000000200000:	ccmp	x18, #0x0, #0xd, pl  &#x2F;&#x2F; special NOP to identity as PE&#x2F;COFF executable
0x0000000000200004:	b	0x1190000 @ &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt; now, go to 0x1190000（primary_entry）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这是整个内核启动部分最重要的函数，所有的东西都在这里做完，然后跳转到start_kernel。下面我们会来重点分析这个部分的内容。详细请看注释。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">&#x2F;&#x2F;注意这里的几个bl指令，覆盖了进入kernel_start前的所有操作
@ SYM_CODE_START(primary_entry)

&#x2F;&#x2F;跳转过去保存boot参数
&#x2F;&#x2F;保存x0(fdt),x1,x2,x3到符号boot_args的变量中,靠dcache_inval_poc中的ret返回到下一行指令
0x0000000001190000:	bl	0x1190020 &#x2F;&#x2F;preserve_boot_args

&#x2F;&#x2F;跳转过去执行不同异常等级的初始化,这里比较复杂，从开始的el2异常级别跳转到el1级别。
0x0000000001190004:	bl	0xd5d000 &#x2F;&#x2F;init_kernel_el

&#x2F;&#x2F;将内核镜像开始地址给x23，也就是0x200000
0x0000000001190008:	adrp	x23, 0x200000
&#x2F;&#x2F; KASLR offset, defaults to 0
0x000000000119000c:	and	x23, x23, #0x1fffff

&#x2F;&#x2F;跳转过去根据w0的值，保存相关的cpu boot mode，注意当前我们的cpu已经处于el1等级，w0 存的是 el2 的标识符
0x0000000001190010:	bl	0xd5d1f8

&#x2F;&#x2F;创建页表，这里面的创建只填充了相关的页表项，并没有开启mmu
&#x2F;&#x2F;idmap &#x3D; 0x117e00, 0x117e0 &#x3D; 0x117f03, 0x117f30 &#x3D; 0x00c00701, 
&#x2F;&#x2F;    注意，这时页表项表示2MB的区域。idmap区域包含了__cpu_setup和__primary_switch
&#x2F;&#x2F;这里执行完，有两个重要的数据结构：idmap_pg_dir 和 init_pg_dir
&#x2F;&#x2F;我们将物理地址__idmap_text_start映射到虚拟地址[__idmap_text_start, __idmap_text_end],注意观察，物理地址和虚拟地址基本是一致的。
&#x2F;&#x2F;还将物理地址_text映射到虚拟地址[KIMAGE_VADDR + KASLR, _end]
0x0000000001190014:	bl	0x1190040

&#x2F;&#x2F;The following calls CPU setup code, see arch&#x2F;arm64&#x2F;mm&#x2F;proc.S
&#x2F;&#x2F;注意，这里已经准备好了SCTLR在x0中，下面就是相关的初始化，然后准备打开mmu的参数
0x0000000001190018:	bl	0xd5d6f4

&#x2F;&#x2F;最终的初始化，开启mmu，并跳转到kernel_start
0x000000000119001c:	b	0xd5d3d8

@ SYM_CODE_END(primary_entry)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  此部分对应保存启动参数，主要还是保存启动时，x0~x3。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">
@ SYM_CODE_START_LOCAL(preserve_boot_args)
&#x2F;&#x2F;x21保存dtb物理地址
0x0000000001190020:	mov	x21, x0
&#x2F;&#x2F;将dtb，x1,x2,x3物理地址存放到变量arch&#x2F;arm64&#x2F;kernel&#x2F;setup.c:u64 __cacheline_aligned boot_args[4];
0x0000000001190024:	adrp	x0, 0x1545000
0x0000000001190028:	add	x0, x0, #0x0
&#x2F;&#x2F;存放dtb,x1
0x000000000119002c:	stp	x21, x1, [x0]
&#x2F;&#x2F;存放x2,x3
0x0000000001190030:	stp	x2, x3, [x0, #16]

@ 刷新cache
0x0000000001190034:	dmb	sy
0x0000000001190038:	add	x1, x0, #0x20
0x000000000119003c:	b	0x2346a8

@ SYM_CODE_END(preserve_boot_args)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  此部分很长，其实主要是汇编代码稍微复杂，其基本的作用就是创建页表，这里面的创建只填充了相关的页表项。分别创建了这里执行完，有两个重要的数据结构：idmap_pg_dir和init_pg_dir的数据结构。这里用的是两级映射，第一级是全局映射，第二级是每个项2MB的映射。这里的idmap_pg_dir映射的是__cpu_setup和__primary_switch部分的内容，这部分主要涉及到mmu开启的过程，需要将物理地址和虚拟地址对应起来。init_pg_dir主要是映射的是kernel虚拟地址和kernel镜像地址。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ SYM_FUNC_START_LOCAL(__create_page_tables)
&#x2F;&#x2F;保存返回值到x28
0x0000000001190040:	mov	x28, x30
&#x2F;&#x2F;加载init_pg_dir 到x0
0x0000000001190044:	adrp	x0, 0x181d000
&#x2F;&#x2F;加载init_pg_end 到x1
0x0000000001190048:	adrp	x1, 0x1820000
@ 刷新cache
0x000000000119004c:	bl	0x2346a8

&#x2F;&#x2F;加载init_pg_dir 到x0
0x0000000001190050:	adrp	x0, 0x181d000
&#x2F;&#x2F;加载init_pg_end 到x1
0x0000000001190054:	adrp	x1, 0x1820000
&#x2F;&#x2F;求出init_pg的大小放入x1中count
0x0000000001190058:	sub	x1, x1, x0
&#x2F;&#x2F;向x0中写入0，然后x1 -&#x3D; 64，当x1等于0时候，所有pg清理完毕。
0x000000000119005c:	stp	xzr, xzr, [x0], #16
0x0000000001190060:	stp	xzr, xzr, [x0], #16
0x0000000001190064:	stp	xzr, xzr, [x0], #16
0x0000000001190068:	stp	xzr, xzr, [x0], #16
0x000000000119006c:	subs	x1, x1, #0x40
0x0000000001190070:	b.ne	0x119005c  &#x2F;&#x2F; b.any

&#x2F;&#x2F;根据配置加载不同的flag, SWAPPER_MM_MMUFLAGS
0x0000000001190074:	mov	x7, #0x701                 	&#x2F;&#x2F; #1793

&#x2F;&#x2F; 获取idmap的页表基地址,idmap_pg_dir
0x0000000001190078:	adrp	x0, 0x117e000
@ 获取idmap的代码段虚地址，__idmap_text_start
0x000000000119007c:	adrp	x3, 0xd5d000
@ 将系统地址线位数给x5, VA_BITS_MIN
0x0000000001190080:	mov	x5, #0x27                  	&#x2F;&#x2F; #39
&#x2F;&#x2F;获取变量地址到x6, vabits_actual
0x0000000001190084:	adrp	x6, 0x1728000
0x0000000001190088:	add	x6, x6, #0x10
&#x2F;&#x2F;将39写入变量vabits_actual
0x000000000119008c:	str	x5, [x6]
0x0000000001190090:	dmb	sy
0x0000000001190094:	dc	ivac, x6

@ 判断虚拟地址空间是否够IDmap来映射
0x0000000001190098:	adrp	x5, 0xd5d000
0x000000000119009c:	clz	x5, x5
0x00000000011900a0:	cmp	x5, #0x19
@ 这里要跳转，不需要扩展虚拟地址
0x00000000011900a4:	b.ge	0x11900e0  &#x2F;&#x2F; b.tcont

@ 这部分是虚拟地址扩展的相关操作，这里不做详解
0x00000000011900a8:	adrp	x6, 0x1555000
0x00000000011900ac:	add	x6, x6, #0xcc8
0x00000000011900b0:	str	x5, [x6]
0x00000000011900b4:	dmb	sy
0x00000000011900b8:	dc	ivac, x6
0x00000000011900bc:	mov	x4, #0x200                 	&#x2F;&#x2F; #512
0x00000000011900c0:	add	x5, x0, #0x1, lsl #12
0x00000000011900c4:	mov	x6, x5
0x00000000011900c8:	orr	x6, x6, #0x3
0x00000000011900cc:	lsr	x5, x3, #39
0x00000000011900d0:	sub	x4, x4, #0x1
0x00000000011900d4:	and	x5, x5, x4
0x00000000011900d8:	str	x6, [x0, x5, lsl #3]
0x00000000011900dc:	add	x0, x0, #0x1, lsl #12

@ 从上面不需要扩展虚拟地址跳转而来，0x00000000011900a4
@ 将512 个 pgd entry存入x4
0x00000000011900e0:	adrp	x4, 0x1555000
0x00000000011900e4:	ldr	x4, [x4, #3280]

@ 将__idmap_text_end放入x6
0x00000000011900e8:	adrp	x6, 0xd5d000
0x00000000011900ec:	add	x6, x6, #0x7e0

@ 这里开始映射[__idmap_text_start, __idmap_text_end] 到 idmap_pg_dir中，
@	且，这部分内容就是cpu_setup部分的内容，恰好对应开启mmu的代码。
&#x2F;&#x2F;tbl:    x0 &#x3D; idmap_pg_dir &#x3D; 0x117e000
&#x2F;&#x2F;rtbl:   x1 &#x3D; 0 
&#x2F;&#x2F;vstart: x3 &#x3D; __idmap_text_start &#x3D; 0xd5d000
&#x2F;&#x2F;vend:   x6 &#x3D; __idmap_text_end &#x3D; 0xd5d7e0
&#x2F;&#x2F;flags:  x7 &#x3D; SWAPPER_MM_MMUFLAGS
&#x2F;&#x2F;phys:   x3 &#x3D; __idmap_text_start &#x3D; 0xd5d000
&#x2F;&#x2F;pgds:   x4 &#x3D; idmap_ptrs_per_pgd &#x3D; 512
&#x2F;&#x2F;tmp regs: x10, x11, x12, x13, x14
@ macro map_memory start ...
@ __idmap_text_end - 1 是idmap映射结束的地方
0x00000000011900f0:	sub	x6, x6, #0x1
@ x1 &#x3D; idmap的页表基地址（idmap_pg_dir） + 2^12 ，并指向了下一个page entry
0x00000000011900f4:	add	x1, x0, #0x1, lsl #12
@ 将x1 保存到 x14
0x00000000011900f8:	mov	x14, x1
@ 将count赋值为0
0x00000000011900fc:	mov	x13, #0x0                   	&#x2F;&#x2F; #0

&#x2F;&#x2F; vstart:	x3 &#x3D; __idmap_text_start &#x3D; 0xd5d000
&#x2F;&#x2F; vend:	x6 &#x3D; __idmap_text_end &#x3D; 0xd5d7e0
&#x2F;&#x2F; shift:	30
&#x2F;&#x2F; ptrs:	x4 &#x3D; idmap_ptrs_per_pgd &#x3D; 512
&#x2F;&#x2F; istart:	x10
&#x2F;&#x2F; iend:	
&#x2F;&#x2F; count:	x13
@ compute_indices  start ...
&#x2F;&#x2F;将vend右逻辑偏移shift(30)位
0x0000000001190100:	lsr	x11, x6, #30
&#x2F;&#x2F;将ptrs（number of entries in page table）存放到istart, 每个表512项
0x0000000001190104:	mov	x10, x4
&#x2F;&#x2F;pte 数量减一
0x0000000001190108:	sub	x10, x10, #0x1

&#x2F;&#x2F;此时算出来vend的pgd index,根据虚拟地址右移30位，还剩9位，恰好表示512个项的id。
&#x2F;&#x2F; iend &#x3D; (vend &gt;&gt; shift) &amp; (ptrs - 1)
0x000000000119010c:	and	x11, x11, x10
0x0000000001190110:	mov	x10, x4
0x0000000001190114:	mul	x10, x10, x13
&#x2F;&#x2F; iend +&#x3D; count * ptrs
0x0000000001190118:	add	x11, x11, x10

&#x2F;&#x2F;将vstart右逻辑偏移shift位
0x000000000119011c:	lsr	x10, x3, #30
0x0000000001190120:	mov	x13, x4
0x0000000001190124:	sub	x13, x13, #0x1
&#x2F;&#x2F; istart &#x3D; (vstart &gt;&gt; shift) &amp; (ptrs - 1), 此时算出来vstart的pgd index
0x0000000001190128:	and	x10, x10, x13
&#x2F;&#x2F;计算出多少项page entry
0x000000000119012c:	sub	x13, x11, x10
@ compute_indices  end ...



@ populate_entries start ... 
0x0000000001190130:	mov	x12, x1
&#x2F;&#x2F;给当前entry设置内存属性
0x0000000001190134:	orr	x12, x12, #0x3
@ 向一级页表idmap_pg_dir（0x117e000）存入二级页表地址（0x117f000）
0x0000000001190138:	str	x12, [x0, x10, lsl #3]
0x000000000119013c:	add	x1, x1, #0x1, lsl #12
0x0000000001190140:	add	x10, x10, #0x1
0x0000000001190144:	cmp	x10, x11
0x0000000001190148:	b.ls	0x1190130  &#x2F;&#x2F; b.plast
@ populate_entries end ... 

&#x2F;&#x2F;注意，这里相当于tbl&#x3D;tbl+PAGE_SIZE,主要还是指向了二级页表
&#x2F;&#x2F;相当于现在一级页表为:idmap_pg_dir（0x117e000）,里面存放的是0x0117f003
&#x2F;&#x2F;这里的x14是二级页表的地址，为0x0117f000
0x000000000119014c:	mov	x0, x14
&#x2F;&#x2F;sv &#x3D; rtbl &#x3D; tbl+PAGE_SIZE+PAGE_SIZE，相当于指向了三级页表
0x0000000001190150:	mov	x14, x1

@ compute_indices  start ...
&#x2F;&#x2F;将vend右逻辑偏移shift位
0x0000000001190154:	lsr	x11, x6, #21
&#x2F;&#x2F;将ptrs（number of entries in page table）存放到istart, 每个表512项
0x0000000001190158:	mov	x10, #0x200                 	&#x2F;&#x2F; #512
&#x2F;&#x2F;pte 数量减一
0x000000000119015c:	sub	x10, x10, #0x1

&#x2F;&#x2F;此时算出来vend的pgd index
&#x2F;&#x2F; iend &#x3D; (vend &gt;&gt; shift) &amp; (ptrs - 1)
0x0000000001190160:	and	x11, x11, x10
0x0000000001190164:	mov	x10, #0x200                 	&#x2F;&#x2F; #512
0x0000000001190168:	mul	x10, x10, x13
&#x2F;&#x2F; iend +&#x3D; count * ptrs
0x000000000119016c:	add	x11, x11, x10

&#x2F;&#x2F;将vstart右逻辑偏移shift位
0x0000000001190170:	lsr	x10, x3, #21
0x0000000001190174:	mov	x13, #0x200                 	&#x2F;&#x2F; #512
0x0000000001190178:	sub	x13, x13, #0x1
&#x2F;&#x2F; istart &#x3D; (vstart &gt;&gt; shift) &amp; (ptrs - 1), 此时算出来vstart的pgd index
0x000000000119017c:	and	x10, x10, x13
&#x2F;&#x2F;计算出多少项page entry
0x0000000001190180:	sub	x13, x11, x10
@ compute_indices  end ...

@ x13 &#x3D; 0xc00000, x3 &#x3D; 0xd5d000
0x0000000001190184:	and	x13, x3, #0xffffffffffe00000

@ populate_entries start ... 
@ x12 &#x3D; 0xc00000
0x0000000001190188:	mov	x12, x13
&#x2F;&#x2F;给当前entry设置内存属性
0x000000000119018c:	orr	x12, x12, x7
@ 向二级页表(0x117f000 + 6*8 &#x3D; 0x117f030)存入地址0xc00701
0x0000000001190190:	str	x12, [x0, x10, lsl #3]
0x0000000001190194:	add	x13, x13, #0x200, lsl #12
0x0000000001190198:	add	x10, x10, #0x1
0x000000000119019c:	cmp	x10, x11
0x00000000011901a0:	b.ls	0x1190188  &#x2F;&#x2F; b.plast
@ populate_entries end ... 

@ init_pg_dir  给x0
0x00000000011901a4:	adrp	x0, 0x181d000
@ KIMAGE_VADDR 给x5
0x00000000011901a8:	mov	x5, #0xffffffc0ffffffff    	&#x2F;&#x2F; #-270582939649
0x00000000011901ac:	movk	x5, #0x800, lsl #16
0x00000000011901b0:	movk	x5, #0x0
&#x2F;&#x2F; add KASLR displacement
0x00000000011901b4:	add	x5, x5, x23
@ 将页表项数目给x4
0x00000000011901b8:	mov	x4, #0x200                 	&#x2F;&#x2F; #512
@ _end 给x6
0x00000000011901bc:	adrp	x6, 0x1820000
@ _start 给x3
0x00000000011901c0:	adrp	x3, 0x200000
@ 求出_end-_start
0x00000000011901c4:	sub	x6, x6, x3
@ 算出基于KIMAGE_VADDR和KASLR的偏移
0x00000000011901c8:	add	x6, x6, x5

&#x2F;&#x2F;tbl:    x0 &#x3D; init_pg_dir
&#x2F;&#x2F;rtbl:   x1 &#x3D; 0
&#x2F;&#x2F;vstart: x5 &#x3D; KIMAGE_VADDR + KASLR
&#x2F;&#x2F;vend:   x6 &#x3D; _end
&#x2F;&#x2F;flags:  x7 &#x3D; SWAPPER_MM_MMUFLAGS
&#x2F;&#x2F;phys:   x3 &#x3D; _text
&#x2F;&#x2F;pgds:   x4 &#x3D; PTRS_PER_PGD
&#x2F;&#x2F;tmp regs: x10, x11, x12, x13, x14
@ macro map_memory start ...
@ 开始填充页表init_pg_dir
0x00000000011901cc:	sub	x6, x6, #0x1
0x00000000011901d0:	add	x1, x0, #0x1, lsl #12
0x00000000011901d4:	mov	x14, x1
0x00000000011901d8:	mov	x13, #0x0                   	&#x2F;&#x2F; #0
0x00000000011901dc:	lsr	x11, x6, #30
0x00000000011901e0:	mov	x10, x4
0x00000000011901e4:	sub	x10, x10, #0x1
0x00000000011901e8:	and	x11, x11, x10
0x00000000011901ec:	mov	x10, x4
0x00000000011901f0:	mul	x10, x10, x13
0x00000000011901f4:	add	x11, x11, x10
0x00000000011901f8:	lsr	x10, x5, #30
0x00000000011901fc:	mov	x13, x4
0x0000000001190200:	sub	x13, x13, #0x1
0x0000000001190204:	and	x10, x10, x13
0x0000000001190208:	sub	x13, x11, x10
0x000000000119020c:	mov	x12, x1
0x0000000001190210:	orr	x12, x12, #0x3
0x0000000001190214:	str	x12, [x0, x10, lsl #3]
0x0000000001190218:	add	x1, x1, #0x1, lsl #12
0x000000000119021c:	add	x10, x10, #0x1
0x0000000001190220:	cmp	x10, x11
0x0000000001190224:	b.ls	0x119020c  &#x2F;&#x2F; b.plast
0x0000000001190228:	mov	x0, x14
0x000000000119022c:	mov	x14, x1
0x0000000001190230:	lsr	x11, x6, #21
0x0000000001190234:	mov	x10, #0x200                 	&#x2F;&#x2F; #512
0x0000000001190238:	sub	x10, x10, #0x1
0x000000000119023c:	and	x11, x11, x10
0x0000000001190240:	mov	x10, #0x200                 	&#x2F;&#x2F; #512
0x0000000001190244:	mul	x10, x10, x13
0x0000000001190248:	add	x11, x11, x10
0x000000000119024c:	lsr	x10, x5, #21
0x0000000001190250:	mov	x13, #0x200                 	&#x2F;&#x2F; #512
0x0000000001190254:	sub	x13, x13, #0x1
0x0000000001190258:	and	x10, x10, x13
0x000000000119025c:	sub	x13, x11, x10
0x0000000001190260:	and	x13, x3, #0xffffffffffe00000
0x0000000001190264:	mov	x12, x13
0x0000000001190268:	orr	x12, x12, x7
0x000000000119026c:	str	x12, [x0, x10, lsl #3]
0x0000000001190270:	add	x13, x13, #0x200, lsl #12
0x0000000001190274:	add	x10, x10, #0x1
0x0000000001190278:	cmp	x10, x11
0x000000000119027c:	b.ls	0x1190264  &#x2F;&#x2F; b.plast
@ macro map_memory end ...


&#x2F;&#x2F;内存屏障
0x0000000001190280:	dmb	sy
@ 刷新cache
0x0000000001190284:	adrp	x0, 0x117e000
0x0000000001190288:	adrp	x1, 0x1181000
0x000000000119028c:	bl	0x2346a8
@ 刷新cache
0x0000000001190290:	adrp	x0, 0x181d000
0x0000000001190294:	adrp	x1, 0x1820000
0x0000000001190298:	bl	0x2346a8
@ 返回到bl	__cpu_setup
0x000000000119029c:	ret	x28


@ SYM_FUNC_END(__create_page_tables)

<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这部分是刷新i/d cache</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">
@ dcache_inval_poc start ...
0x00000000002346a8:	mrs	x3, ctr_el0
0x00000000002346ac:	nop
0x00000000002346b0:	ubfx	x3, x3, #16, #4
0x00000000002346b4:	mov	x2, #0x4                   	&#x2F;&#x2F; #4
0x00000000002346b8:	lsl	x2, x2, x3
0x00000000002346bc:	sub	x3, x2, #0x1
0x00000000002346c0:	tst	x1, x3
0x00000000002346c4:	bic	x1, x1, x3
0x00000000002346c8:	b.eq	0x2346d0  &#x2F;&#x2F; b.none
0x00000000002346cc:	dc	civac, x1
0x00000000002346d0:	tst	x0, x3
0x00000000002346d4:	bic	x0, x0, x3
0x00000000002346d8:	b.eq	0x2346e4  &#x2F;&#x2F; b.none
0x00000000002346dc:	dc	civac, x0
0x00000000002346e0:	b	0x2346e8
0x00000000002346e4:	dc	ivac, x0
0x00000000002346e8:	add	x0, x0, x2
0x00000000002346ec:	cmp	x0, x1
0x00000000002346f0:	b.cc	0x2346e4  &#x2F;&#x2F; b.lo, b.ul, b.last
0x00000000002346f4:	dsb	sy
0x00000000002346f8:	ret
@ dcache_inval_poc end ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这部分就是对应的是开始的在el2模式下初始化，并返回到el1，并保存启动参数。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ SYM_FUNC_START(init_kernel_el)
&#x2F;&#x2F;读取当前的异常等级
0x0000000000d5d000:	mrs	x0, currentel
&#x2F;&#x2F;判断是否为异常等级2
0x0000000000d5d004:	cmp	x0, #0x8
&#x2F;&#x2F;跳转到el2(qemu 模拟机器执行路径)， init_el2
0x0000000000d5d008:	b.eq	0xd5d034  &#x2F;&#x2F; b.none
0x0000000000d5d00c:	mov	x0, #0x30500000            	&#x2F;&#x2F; #810549248
0x0000000000d5d010:	movk	x0, #0x800
0x0000000000d5d014:	msr	sctlr_el1, x0
0x0000000000d5d018:	isb
0x0000000000d5d01c:	movz	x0, #0x0, lsl #16
0x0000000000d5d020:	movk	x0, #0x3c5
0x0000000000d5d024:	msr	spsr_el1, x0
0x0000000000d5d028:	msr	elr_el1, x30
0x0000000000d5d02c:	mov	w0, #0xe11                 	&#x2F;&#x2F; #3601
0x0000000000d5d030:	eret

@ init_el2 start ... ...
&#x2F;&#x2F;配置hcr_el2寄存器,HCR(Hypervisor Configuration Register)
0x0000000000d5d034:	mov	x0, #0x100000000000000     	&#x2F;&#x2F; #72057594037927936
0x0000000000d5d038:	movk	x0, #0x300, lsl #32
0x0000000000d5d03c:	movk	x0, #0x8000, lsl #16
0x0000000000d5d040:	movk	x0, #0x0
0x0000000000d5d044:	msr	hcr_el2, x0
&#x2F;&#x2F;ISB. 指令同步屏障
0x0000000000d5d048:	isb

&#x2F;&#x2F;初始化el2下的各种状态
&#x2F;*
.macro init_el2_state
	__init_el2_sctlr
	__init_el2_timers
	__init_el2_debug
	__init_el2_lor
	__init_el2_stage2
	__init_el2_gicv3
	__init_el2_hstr
	__init_el2_nvhe_idregs
	__init_el2_nvhe_cptr
	__init_el2_nvhe_sve
	__init_el2_fgt
	__init_el2_nvhe_prepare_eret
.endm
*&#x2F;

&#x2F;&#x2F;__init_el2_sctlr
0x0000000000d5d04c:	mov	x0, #0x30c50000            	&#x2F;&#x2F; #818216960
0x0000000000d5d050:	movk	x0, #0x830
0x0000000000d5d054:	msr	sctlr_el2, x0
0x0000000000d5d058:	isb

&#x2F;&#x2F;__init_el2_timers
0x0000000000d5d05c:	mov	x0, #0x3                   	&#x2F;&#x2F; #3
0x0000000000d5d060:	msr	cnthctl_el2, x0
0x0000000000d5d064:	msr	cntvoff_el2, xzr

&#x2F;&#x2F;__init_el2_debug
0x0000000000d5d068:	mrs	x1, id_aa64dfr0_el1
0x0000000000d5d06c:	sbfx	x0, x1, #8, #4
0x0000000000d5d070:	cmp	x0, #0x1
0x0000000000d5d074:	b.lt	0xd5d080  &#x2F;&#x2F; b.tstop
0x0000000000d5d078:	mrs	x0, pmcr_el0
0x0000000000d5d07c:	ubfx	x0, x0, #11, #5
0x0000000000d5d080:	csel	x2, xzr, x0, lt  &#x2F;&#x2F; lt &#x3D; tstop
0x0000000000d5d084:	ubfx	x0, x1, #32, #4
0x0000000000d5d088:	cbz	x0, 0xd5d0a8
0x0000000000d5d08c:	mrs	x0, pmbidr_el1
0x0000000000d5d090:	and	x0, x0, #0x10
0x0000000000d5d094:	cbnz	x0, 0xd5d0a0
0x0000000000d5d098:	mov	x0, #0x50                  	&#x2F;&#x2F; #80
0x0000000000d5d09c:	msr	pmscr_el2, x0
0x0000000000d5d0a0:	mov	x0, #0x3000                	&#x2F;&#x2F; #12288
0x0000000000d5d0a4:	orr	x2, x2, x0
0x0000000000d5d0a8:	ubfx	x0, x1, #44, #4
0x0000000000d5d0ac:	cbz	x0, 0xd5d0c4
0x0000000000d5d0b0:	mrs	x0, s3_0_c9_c11_7
0x0000000000d5d0b4:	and	x0, x0, #0x10
0x0000000000d5d0b8:	cbnz	x0, 0xd5d0c4
0x0000000000d5d0bc:	mov	x0, #0x3000000             	&#x2F;&#x2F; #50331648
0x0000000000d5d0c0:	orr	x2, x2, x0
0x0000000000d5d0c4:	msr	mdcr_el2, x2

&#x2F;&#x2F;__init_el2_lor
0x0000000000d5d0c8:	mrs	x1, id_aa64mmfr1_el1
0x0000000000d5d0cc:	ubfx	x0, x1, #16, #4
0x0000000000d5d0d0:	cbz	x0, 0xd5d0d8
0x0000000000d5d0d4:	msr	s3_0_c10_c4_3, xzr

&#x2F;&#x2F;__init_el2_stage2
0x0000000000d5d0d8:	msr	vttbr_el2, xzr

&#x2F;&#x2F;__init_el2_gicv3
0x0000000000d5d0dc:	mrs	x0, id_aa64pfr0_el1
0x0000000000d5d0e0:	ubfx	x0, x0, #24, #4
0x0000000000d5d0e4:	cbz	x0, 0xd5d108
0x0000000000d5d0e8:	mrs	x0, s3_4_c12_c9_5
0x0000000000d5d0ec:	orr	x0, x0, #0x1
0x0000000000d5d0f0:	orr	x0, x0, #0x8
0x0000000000d5d0f4:	msr	s3_4_c12_c9_5, x0
0x0000000000d5d0f8:	isb
0x0000000000d5d0fc:	mrs	x0, s3_4_c12_c9_5
0x0000000000d5d100:	tbz	w0, #0, 0xd5d108
0x0000000000d5d104:	msr	s3_4_c12_c11_0, xzr

&#x2F;&#x2F;__init_el2_hstr
0x0000000000d5d108:	msr	hstr_el2, xzr

&#x2F;&#x2F;__init_el2_nvhe_idregs
0x0000000000d5d10c:	mrs	x0, midr_el1
0x0000000000d5d110:	mrs	x1, mpidr_el1
0x0000000000d5d114:	msr	vpidr_el2, x0
0x0000000000d5d118:	msr	vmpidr_el2, x1

&#x2F;&#x2F;__init_el2_nvhe_cptr
0x0000000000d5d11c:	mov	x0, #0x33ff                	&#x2F;&#x2F; #13311
0x0000000000d5d120:	msr	cptr_el2, x0

&#x2F;&#x2F;__init_el2_nvhe_sve
0x0000000000d5d124:	mrs	x1, id_aa64pfr0_el1
0x0000000000d5d128:	ubfx	x1, x1, #32, #4
0x0000000000d5d12c:	cbz	x1, 0xd5d144
0x0000000000d5d130:	and	x0, x0, #0xfffffffffffffeff
0x0000000000d5d134:	msr	cptr_el2, x0
0x0000000000d5d138:	isb
0x0000000000d5d13c:	mov	x1, #0x1ff                 	&#x2F;&#x2F; #511
0x0000000000d5d140:	msr	zcr_el2, x1

&#x2F;&#x2F;__init_el2_fgt
0x0000000000d5d144:	mrs	x1, id_aa64mmfr0_el1
0x0000000000d5d148:	ubfx	x1, x1, #56, #4
0x0000000000d5d14c:	cbz	x1, 0xd5d18c
0x0000000000d5d150:	mov	x0, xzr
0x0000000000d5d154:	mrs	x1, id_aa64dfr0_el1
0x0000000000d5d158:	ubfx	x1, x1, #32, #4
0x0000000000d5d15c:	cmp	x1, #0x3
0x0000000000d5d160:	b.lt	0xd5d168  &#x2F;&#x2F; b.tstop
0x0000000000d5d164:	orr	x0, x0, #0x4000000000000000
0x0000000000d5d168:	msr	s3_4_c3_c1_4, x0
0x0000000000d5d16c:	msr	s3_4_c3_c1_5, x0
0x0000000000d5d170:	msr	s3_4_c1_c1_4, xzr
0x0000000000d5d174:	msr	s3_4_c1_c1_5, xzr
0x0000000000d5d178:	msr	s3_4_c1_c1_6, xzr
0x0000000000d5d17c:	mrs	x1, id_aa64pfr0_el1
0x0000000000d5d180:	ubfx	x1, x1, #44, #4
0x0000000000d5d184:	cbz	x1, 0xd5d18c
0x0000000000d5d188:	msr	s3_4_c3_c1_6, xzr

&#x2F;&#x2F; __init_el2_nvhe_prepare_eret
0x0000000000d5d18c:	mov	x0, #0x3c5                 	&#x2F;&#x2F; #965
0x0000000000d5d190:	msr	spsr_el2, x0


&#x2F;&#x2F;加载el2的中断向量表
0x0000000000d5d194:	adrp	x0, 0xd4f000
0x0000000000d5d198:	add	x0, x0, #0x0
0x0000000000d5d19c:	msr	vbar_el2, x0
0x0000000000d5d1a0:	isb

&#x2F;*
	* Fruity CPUs seem to have HCR_EL2.E2H set to RES1,
	* making it impossible to start in nVHE mode. Is that
	* compliant with the architecture? Absolutely not!
*&#x2F;
0x0000000000d5d1a4:	mrs	x0, hcr_el2
0x0000000000d5d1a8:	and	x0, x0, #0x400000000
&#x2F;&#x2F;跳转到1f(0xd5d1d0)位置继续执行
0x0000000000d5d1ac:	cbz	x0, 0xd5d1d0

0x0000000000d5d1b0:	mov	x0, #0x30500000            	&#x2F;&#x2F; #810549248
0x0000000000d5d1b4:	movk	x0, #0x800
0x0000000000d5d1b8:	msr	sctlr_el12, x0
0x0000000000d5d1bc:	mov	x0, #0x3c9                 	&#x2F;&#x2F; #969
0x0000000000d5d1c0:	msr	spsr_el1, x0
0x0000000000d5d1c4:	adr	x0, 0xd5d1e8
0x0000000000d5d1c8:	msr	elr_el1, x0
0x0000000000d5d1cc:	eret

&#x2F;&#x2F;将x0写入sctlr_el1
0x0000000000d5d1d0:	mov	x0, #0x30500000            	&#x2F;&#x2F; #810549248
0x0000000000d5d1d4:	movk	x0, #0x800
0x0000000000d5d1d8:	msr	sctlr_el1, x0

&#x2F;&#x2F;将当前的lr(x30)地址放到elr_el2中，后续eret到el1时，跳转到此地址执行
0x0000000000d5d1dc:	msr	elr_el2, x30
&#x2F;&#x2F;将flag写入w0中
0x0000000000d5d1e0:	mov	w0, #0xe12                 	&#x2F;&#x2F; #3602
&#x2F;&#x2F;注意这里的返回值，这里返回到elr_el2指向的地方，
&#x2F;&#x2F;也就是adrp	x23, __PHYS_OFFSET, 0x0000000001190008
0x0000000000d5d1e4:	eret


0x0000000000d5d1e8:	mov	x0, #0x3                   	&#x2F;&#x2F; #3
0x0000000000d5d1ec:	hvc	#0x0
0x0000000000d5d1f0:	mov	x0, #0xe12                 	&#x2F;&#x2F; #3602
0x0000000000d5d1f4:	ret

@ SYM_FUNC_END(init_kernel_el)


@ SYM_FUNC_START_LOCAL(set_cpu_boot_mode_flag)
&#x2F;&#x2F;加载__boot_cpu_mode符号地址，此地址存放
0x0000000000d5d1f8:	adrp	x1, 0x1728000
0x0000000000d5d1fc:	add	x1, x1, #0x0
0x0000000000d5d200:	cmp	w0, #0xe12
0x0000000000d5d204:	b.ne	0xd5d20c  &#x2F;&#x2F; b.any
0x0000000000d5d208:	add	x1, x1, #0x4
0x0000000000d5d20c:	str	w0, [x1]
0x0000000000d5d210:	dmb	sy
0x0000000000d5d214:	dc	ivac, x1
@ 返回到0x0000000001190014
0x0000000000d5d218:	ret

@ SYM_FUNC_END(set_cpu_boot_mode_flag)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这里包含3个步骤：</p>
<ol>
<li class="lvl-3">
<p>这里其实包含了开启mmu，mmu开启时，tbbr0_el1是idmap_pg_dir，tbbr1_el1是init_pg_dir，还是使用的物理地址，所以这个时候的地址翻译由页表idmap_pg_dir来支持。</p>
</li>
<li class="lvl-3">
<p>当完成mmu开启后，就会将.rela.dyn段实现重定位，因为这部分的符号的实际地址为0，需要我们填写为实际的符号地址。</p>
</li>
<li class="lvl-3">
<p>当重定位完成后，会加载__primary_switched的虚拟地址，其地址在内核空间，当执行blr 跳转到__primary_switched的时候，这个时候的地址返回由页表init_pg_dir来支持。</p>
</li>
</ol>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ SYM_FUNC_START(__enable_mmu)
&#x2F;*
符合ARMv8的PE最大支持的物理地址宽度也是48个bit，当然，具体的实现可以自己定义
（不能超过48个bit），具体的配置可以通过ID_AA64MMFR0_EL1 
（AArch64 Memory Model Feature Register 0）这个RO寄存器获取
*&#x2F;
0xd5d308        mrs    x2, id_aa64mmfr0_el1     
@ 判断物理地址宽度是否满足最小和最大的要求。
0xd5d30c        ubfx   x2, x2, #28, #4                                        
0xd5d310        cmp    x2, #0x0                                               
0xd5d314        b.lt   0xd5d36c  &#x2F;&#x2F; b.tstop                                   
0xd5d318        cmp    x2, #0x7                                               
0xd5d31c        b.gt   0xd5d36c     

&#x2F;&#x2F;update_early_cpu_boot_status
0xd5d320        mov    x3, #0x0                        &#x2F;&#x2F; #0                  
0xd5d324        adrp   x2, 0x1728000                                          
0xd5d328        add    x2, x2, #0x8                                           
0xd5d32c        str    x3, [x2]                                               
0xd5d330        dmb    sy                                                     
0xd5d334        dc     ivac, x2   

&#x2F;&#x2F;加载idmap_pg_dir到ttbr0
&#x2F;&#x2F;注意，跳转过来时，x1是init_gdir
0xd5d338        adrp   x2, 0x117e000                                          
0xd5d33c        mov    x1, x1                                                 
0xd5d340        mov    x2, x2           

&#x2F;&#x2F;加载两个映射表到tbbr0和1,在el1模式下面
0xd5d344        msr    ttbr0_el1, x2                                          
0xd5d348        msr    ttbr1_el1, x1                                          
0xd5d34c        isb     

&#x2F;&#x2F;打开mmu
0xd5d350        msr    sctlr_el1, x0                                          
0xd5d354        isb                                                           
0xd5d358        ic     iallu                                                  
0xd5d35c        dsb    nsh                                                    
0xd5d360        isb                                                           
0xd5d364        ret  
@ SYM_FUNC_END(__enable_mmu)

&#x2F;&#x2F;此部分作用为解决符号重定位问题
&#x2F;&#x2F;readelf -r vmlinux 读取重定位表
&#x2F;&#x2F;readelf -S vmlinux 读取所有section头
&#x2F;&#x2F;hexdump -s 0x24000 -n 16 vmlinux 读取重定位表中的第一项的目的地址内容，
&#x2F;&#x2F;       可以发现为8个0，需要我们来手动填写符号重定位地址
@ SYM_FUNC_START_LOCAL(__relocate_kernel)
0xd5d390        ldr    w9, 0xd5d438   &#x2F;&#x2F; offset to reloc table                                                                                                                                    │
0xd5d394        ldr    w10, 0xd5d43c  &#x2F;&#x2F; size of reloc table  
&#x2F;&#x2F; default virtual offset                                                                                                                                  │
0xd5d398        mov    x11, #0xffffffc0ffffffff        &#x2F;&#x2F; #-270582939649                                                                                                  │
0xd5d39c        movk   x11, #0x800, lsl #16                                                                                                                               │
0xd5d3a0        movk   x11, #0x0     
&#x2F;&#x2F; actual virtual offset                                                                                                                                     │
0xd5d3a4        add    x11, x11, x23   
&#x2F;&#x2F; x9保存了.rela.dyn区域的链接地址
&#x2F;&#x2F; x10保存了.rela.dyn区域的结束地址                                                                                                                                   │
0xd5d3a8        add    x9, x9, x11                                                                                                                                        │
0xd5d3ac        add    x10, x9, x10                                                                                                                                       │
0xd5d3b0        cmp    x9, x10                                                                                                                                            │
0xd5d3b4        b.cs   0xd5d3d4  &#x2F;&#x2F; b.hs, b.nlast 
&#x2F;&#x2F;获取一项offset和info+flag                                                                                                                        │
0xd5d3b8        ldp    x12, x13, [x9], #24      
&#x2F;&#x2F;获取Addend值                                                                                                                          │
0xd5d3bc        ldur   x14, [x9, #-8]                                                                                                                                     │
0xd5d3c0        cmp    w13, #0x403                                                                                                                                        │
0xd5d3c4        b.ne   0xd5d3b0  &#x2F;&#x2F; b.any    
&#x2F;&#x2F;&#x2F;&#x2F; relocate,这里主要是修正[offset + KASLR offset] &#x3D; KASLR offset + append的值,也就是符号重定位了                                                                                                                             │
0xd5d3c8        add    x14, x14, x23                                                                                                                                      │
0xd5d3cc        str    x14, [x12, x23]                                                                                                                                    │
0xd5d3d0        b      0xd5d3b0                                                                                                                                           │
0xd5d3d4        ret    
@ SYM_FUNC_END(__relocate_kernel)

@ SYM_FUNC_START_LOCAL(__primary_switch)
0xd5d3d8        mov    x19, x0         &#x2F;&#x2F; preserve new SCTLR_EL1 value         
0xd5d3dc        mrs    x20, sctlr_el1  &#x2F;&#x2F; preserve old SCTLR_EL1 value         
0xd5d3e0        adrp   x1, 0x181d000   &#x2F;&#x2F; 将init_pg_dir 给x1  
&#x2F;&#x2F;跳转过去初始化mmu                                                            
0xd5d3e4        bl     0xd5d308        &#x2F;&#x2F;__enable_mmu        
&#x2F;&#x2F;将kernel image的.rela.dyn段实现重定位                  
0xd5d3e8        bl     0xd5d390        &#x2F;&#x2F;__relocate_kernel       

&#x2F;&#x2F;注意ldr指令加载的是__primary_switched的链接地址，
&#x2F;&#x2F;    注意这里的链接地址已经是虚拟地址了（例子值为：0xffffffc008f902a0）              
0xd5d3ec        ldr    x8, 0xd5d448    &#x2F;&#x2F;__primary_switched给x8                
0xd5d3f0        adrp   x0, 0x200000    &#x2F;&#x2F;__PHYS_OFFSET给x0   
&#x2F;&#x2F;注意这里的跳转指令，这个时候mmu已经生效了，由于目标地址为0xffffffc008f902a0，
&#x2F;&#x2F;      所以这个时候查询的页表为init_pg_dir                  
0xd5d3f4        blr    x8  &#x2F;&#x2F;跳转到__primary_switched                          
0xd5d3f8        isb                                                           
0xd5d3fc        msr    sctlr_el1, x20                                         
0xd5d400        isb                                                           
0xd5d404        bl     0x1190040                                              
0xd5d408        tlbi   vmalle1                                                
0xd5d40c        dsb    nsh                                                    
0xd5d410        isb                                                           
0xd5d414        msr    sctlr_el1, x19                                         
0xd5d418        isb                                                           
0xd5d41c        ic     iallu                                                  
0xd5d420        dsb    nsh                                                    
0xd5d424        isb                                                           
0xd5d428        bl     0xd5d390                                               
0xd5d42c        ldr    x8, 0xd5d448                                           
0xd5d430        adrp   x0, 0x200000                                           
0xd5d434        br     x8        
@ SYM_FUNC_END(__primary_switch)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  这部分主要是在页表初始化好后，进行el1的一些cpu设置，并准备好mmu开启参数。</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ 	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;
@ SYM_FUNC_START(__cpu_setup)
&#x2F;&#x2F; Invalidate local TLB
0x0000000000d5d6f4:	tlbi	vmalle1
0x0000000000d5d6f8:	dsb	nsh

0x0000000000d5d6fc:	mov	x1, #0x300000              	&#x2F;&#x2F; #3145728
&#x2F;&#x2F; Enable FP&#x2F;ASIMD
0x0000000000d5d700:	msr	cpacr_el1, x1
&#x2F;&#x2F; Reset mdscr_el1 and disable
0x0000000000d5d704:	mov	x1, #0x1000                	&#x2F;&#x2F; #4096
&#x2F;&#x2F; access to the DCC from EL0
0x0000000000d5d708:	msr	mdscr_el1, x1
&#x2F;&#x2F; Unmask debug exceptions now,
0x0000000000d5d70c:	isb


0x0000000000d5d710:	msr	daifclr, #0x8
0x0000000000d5d714:	mrs	x1, id_aa64dfr0_el1
0x0000000000d5d718:	sbfx	x1, x1, #8, #4
0x0000000000d5d71c:	cmp	x1, #0x1
0x0000000000d5d720:	b.lt	0xd5d728  &#x2F;&#x2F; b.tstop
0x0000000000d5d724:	msr	pmuserenr_el0, xzr
0x0000000000d5d728:	mrs	x1, id_aa64pfr0_el1
0x0000000000d5d72c:	ubfx	x1, x1, #44, #4
0x0000000000d5d730:	cbz	x1, 0xd5d738
0x0000000000d5d734:	msr	s3_3_c13_c2_3, xzr
0x0000000000d5d738:	mov	x17, #0x400000000           	&#x2F;&#x2F; #17179869184
0x0000000000d5d73c:	movk	x17, #0x44, lsl #16
0x0000000000d5d740:	movk	x17, #0xffff
0x0000000000d5d744:	mov	x16, #0x40000000000000      	&#x2F;&#x2F; #18014398509481984
0x0000000000d5d748:	movk	x16, #0x30, lsl #32
0x0000000000d5d74c:	movk	x16, #0xb559, lsl #16
0x0000000000d5d750:	movk	x16, #0x3519
0x0000000000d5d754:	mrs	x9, midr_el1
0x0000000000d5d758:	mov	x5, #0xffffffffffefffff    	&#x2F;&#x2F; #-1048577
0x0000000000d5d75c:	movk	x5, #0xffff
0x0000000000d5d760:	and	x9, x9, x5
0x0000000000d5d764:	mov	x5, #0x460f0000            	&#x2F;&#x2F; #1175388160
0x0000000000d5d768:	movk	x5, #0x10
0x0000000000d5d76c:	cmp	x9, x5
0x0000000000d5d770:	b.ne	0xd5d788  &#x2F;&#x2F; b.any
0x0000000000d5d774:	mov	x5, #0x60000000000000      	&#x2F;&#x2F; #27021597764222976
0x0000000000d5d778:	movk	x5, #0x0, lsl #32
0x0000000000d5d77c:	movk	x5, #0x0, lsl #16
0x0000000000d5d780:	movk	x5, #0x0
0x0000000000d5d784:	bic	x16, x16, x5
0x0000000000d5d788:	adrp	x9, 0x1555000
0x0000000000d5d78c:	ldr	x9, [x9, #3272]
0x0000000000d5d790:	bfxil	x16, x9, #0, #6
0x0000000000d5d794:	mrs	x5, id_aa64mmfr0_el1
0x0000000000d5d798:	ubfx	x5, x5, #0, #3
0x0000000000d5d79c:	mov	x6, #0x5                   	&#x2F;&#x2F; #5
0x0000000000d5d7a0:	cmp	x5, x6
0x0000000000d5d7a4:	csel	x5, x6, x5, hi  &#x2F;&#x2F; hi &#x3D; pmore
0x0000000000d5d7a8:	bfi	x16, x5, #32, #3


0x0000000000d5d7ac:	mrs	x9, id_aa64mmfr1_el1
0x0000000000d5d7b0:	and	x9, x9, #0xf
0x0000000000d5d7b4:	cbz	x9, 0xd5d7bc
0x0000000000d5d7b8:	orr	x16, x16, #0x8000000000


0x0000000000d5d7bc:	msr	mair_el1, x17
0x0000000000d5d7c0:	msr	tcr_el1, x16

&#x2F;*
  * Prepare SCTLR, INIT_SCTLR_EL1_MMU_ON 给 x0
  *&#x2F;
0x0000000000d5d7c4:	mov	x0, #0x200000000000000     	&#x2F;&#x2F; #144115188075855872
0x0000000000d5d7c8:	movk	x0, #0x20, lsl #32
0x0000000000d5d7cc:	movk	x0, #0x34f4, lsl #16
0x0000000000d5d7d0:	movk	x0, #0xd91d

&#x2F;&#x2F; return to head.S
0x0000000000d5d7d4:	ret
0x0000000000d5d7d8:	msr	tpidr_el2, x13
0x0000000000d5d7dc:	msr	disr_el1, xzr
@ SYM_FUNC_END(__cpu_setup)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  当我们进入__primary_switched的时候，这个时候用的是内核地址。同时地址翻译是由init_pg_dir来完成。此过程初始化init_task，将</p>
<pre class="line-numbers language-asm" data-language="asm"><code class="language-asm">@ SYM_FUNC_START_LOCAL(__primary_switched)

&#x2F;&#x2F;将init_task给x4
0xffffffc008f902a0      adrp   x4, 0xffffffc00934f000 &lt;inet6_offloads+1376&gt;                        
0xffffffc008f902a4      add    x4, x4, #0xb80   

&#x2F;&#x2F;init_cpu_task                                                   
0xffffffc008f902a8      msr    sp_el0, x4                                                          
0xffffffc008f902ac      ldr    x5, [x4, #24]                                                       
0xffffffc008f902b0      add    sp, x5, #0x4, lsl #12                                               
0xffffffc008f902b4      sub    sp, sp, #0x150                                                      
0xffffffc008f902b8      stp    xzr, xzr, [sp, #304]                                                
0xffffffc008f902bc      add    x29, sp, #0x130                                                     
0xffffffc008f902c0      adrp   x5, 0xffffffc009349000 &lt;event_hash+616&gt;                             
0xffffffc008f902c4      add    x5, x5, #0x7f8                                                      
0xffffffc008f902c8      ldr    w6, [x4, #64]                                                       
0xffffffc008f902cc      ldr    x5, [x5, x6, lsl #3]                                                
0xffffffc008f902d0      msr    tpidr_el1, x5          

&#x2F;&#x2F;加载异常向量表地址                                                                             
0xffffffc008f902d4      adrp   x8, 0xffffffc008010000 &lt;bcm2835_handle_irq&gt;                         
0xffffffc008f902d8      add    x8, x8, #0x800                                                      
0xffffffc008f902dc      msr    vbar_el1, x8                                                        
0xffffffc008f902e0      isb 

&#x2F;&#x2F;将x29,x30放入到sp
0xffffffc008f902e4      stp    x29, x30, [sp, #-16]!                                               
0xffffffc008f902e8      mov    x29, sp  

&#x2F;&#x2F; Save FDT pointer                                                                                                        
0xffffffc008f902ec      adrp   x5, 0xffffffc009001000 &lt;tmp_cmdline.73085+2040&gt;                     
0xffffffc008f902f0      str    x21, [x5, #920]                      

&#x2F;&#x2F; Save the offset between                                                                              
0xffffffc008f902f4      adrp   x4, 0xffffffc008b70000 &lt;kimage_vaddr&gt;                                                                              
0xffffffc008f902f8      ldr    x4, [x4]       
&#x2F;&#x2F; the kernel virtual and                                                                                                    
0xffffffc008f902fc      sub    x4, x4, x0                                    
&#x2F;&#x2F; physical mappings                                                                     
0xffffffc008f90300      adrp   x5, 0xffffffc008ebb000 &lt;rt_sched_class+192&gt;                                                                        
0xffffffc008f90304      str    x4, [x5, #3392]       

&#x2F;&#x2F;Clear BSS                                                                                             
0xffffffc008f90308      adrp   x0, 0xffffffc009529000 &lt;__kvm_nvhe_cur&gt;                                                                            
0xffffffc008f9030c      add    x0, x0, #0x0                                                                                                       
0xffffffc008f90310      mov    x1, xzr                                                                                                            
0xffffffc008f90314      adrp   x2, 0xffffffc00961c000 &lt;gssp_stats+24&gt;                                                                             
0xffffffc008f90318      add    x2, x2, #0xf8                                                                                                      
0xffffffc008f9031c      sub    x2, x2, x0                                                                                                         
0xffffffc008f90320      bl     0xffffffc008664200 &lt;memset&gt;                                                                                        
0xffffffc008f90324      dsb    ishst    

&#x2F;&#x2F; pass FDT address in x0                                                                                                          
0xffffffc008f90328      mov    x0, x21    
&#x2F;&#x2F; Try mapping the FDT early                                                                                                        
0xffffffc008f9032c      bl     0xffffffc008f946c8 &lt;early_fdt_map&gt;    
&#x2F;&#x2F; Parse cpu feature overrides                                                                    
0xffffffc008f90330      bl     0xffffffc008f96354 &lt;init_feature_override&gt;    
&#x2F;&#x2F;already running randomized?                                                                     
0xffffffc008f90334      tst    x23, #0xffffffffffe00000                                                                                           
0xffffffc008f90338      b.ne   0xffffffc008f90350 &lt;__primary_switched+176&gt;  &#x2F;&#x2F; b.any
&#x2F;&#x2F; parse FDT for KASLR options                                                              
0xffffffc008f9033c      bl     0xffffffc008f96b80 &lt;kaslr_early_init&gt;  
&#x2F;&#x2F; KASLR disabled? just proceed          这里直接跳转到 0xffffffc008f90350                                                              
0xffffffc008f90340      cbz    x0, 0xffffffc008f90350 &lt;__primary_switched+176&gt;  
&#x2F;&#x2F; record KASLR offset                                                                  
0xffffffc008f90344      orr    x23, x23, x0  
&#x2F;&#x2F; we must enable KASLR, return                                                                                                     
0xffffffc008f90348      ldp    x29, x30, [sp], #16      
&#x2F;&#x2F; to __primary_switch()                                                                                         
0xffffffc008f9034c      ret  

&#x2F;&#x2F; Prefer VHE if possible
0xffffffc008f90350      bl     0xffffffc008021e6c &lt;switch_to_vhe&gt;                                                                                 
0xffffffc008f90354      ldp    x29, x30, [sp], #16                  
&#x2F;&#x2F;跳转到kernel_start                                                                              
0xffffffc008f90358      bl     0xffffffc008f90c40 &lt;start_kernel&gt;                                                                                  
0xffffffc008f9035c      brk    #0x800                                                                                                             
0xffffffc008f90360      msr    tpidr_el2, x5  
@ SYM_FUNC_END(__primary_switched)
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  注意，阅读本文这部分时，需要对照着head.S来看，这样才有一个基本的认识。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  本文得到的基本流程为，上电，保存上电后的基础寄存器，在el2的模式下初始化cpu，保存启动标志，初始化两个页表（注意，这部分是精华，我这部分注释也最多），然后初始化el1模式下的cpu，并准备好开启mmu，最后在__primary_switch里面开启mmu，当mmu开启后，这个时候的地址还是物理地址，所以我们需要一个映射物理地址和虚拟地址相等的页表（idmap_pg_dir），重定位符号表，最后加载__primary_switched的虚拟地址（其虚拟地址在kernel logical memory map中），跳转到执行（此时查表init_pg_dir），然后初始化init_task，最后进入start_kernel。</p>
<p>  本文也没有尝试去完全注释每句代码，太繁杂了，对于我来说也没有意义，特别是一些特别的初始化，只有以后遇到了才去查询。Linux现代内核太大了，后面可能就要去看个人喜欢的模块，这样才有收获，不要尝试去阅读全部内容，那样太难了。</p>
<p>  每个人对于这部分的关注可能都是不一样的，如果本文没有写的地方，可以尝试搜索对应的关键字，可以得到更多的信息。</p>
<h3 id="参考文献">参考文献</h3>
<div id="refer-anchor-1"></div>
[1]https://blog.csdn.net/u011728480/article/details/79498816
<div id="refer-anchor-2"></div>
[2]https://blog.csdn.net/u011728480/article/details/88420467
<div id="refer-anchor-3"></div>
[3]https://blog.csdn.net/u011728480/article/details/88553602
<div id="refer-anchor-4"></div>
[4]https://blog.csdn.net/u011728480/article/details/114491022
<div id="refer-anchor-5"></div>
[5]https://developer.arm.com/documentation/100933/0100
<div id="refer-anchor-6"></div>
[6]https://www.kernel.org/doc/html/latest/arm64/memory.html
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/03/17/blog_idx_128/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/17/blog_idx_128/" class="post-title-link" itemprop="url">关于进程同步与互斥的一些概念（锁、cas、futex）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-17 19:43:00" itemprop="dateCreated datePublished" datetime="2024-03-17T19:43:00+08:00">2024-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-18 19:06:02" itemprop="dateModified" datetime="2024-05-18T19:06:02+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/linux/C-CPP/" itemprop="url" rel="index"><span itemprop="name">C&CPP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=128） 
&emsp;&emsp;本文发布于 2024-03-17 19:43:00             （BlogID=128） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  最近为了实现在android linux kernel上，是的bionic c和glibc的sem_<em>相关的信号量接口能够相互调用的功能（例如：用bionic c wait，用glibc awake），需要去深度阅读相关c库关于sem_</em> posix api的实现。</p>
<p>  最终的最终，发现主要要解决futex的问题就行。因此将其相关的概念进行了总结。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="进程同步与互斥的一些基本概念">进程同步与互斥的一些基本概念</h3>
<hr>
<p>  进程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>是操作系统调度的基本单位。</p>
</li>
</ul>
<p>  进程状态：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>三态模型：运行、就绪、等待（阻塞/睡眠）</p>
</li>
<li class="lvl-2">
<p>五态模型：运行、就绪、等待（阻塞/睡眠） + 新建、终止</p>
</li>
</ul>
<p>  进程调度：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>因某些原因（io等待，自己睡眠，调度公平等等），一个或者多个进程需要进行状态切换。</p>
</li>
</ul>
<p>  进程工作特性分类：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>计算密集型：进程的主要工作是计算某些事情。</p>
</li>
<li class="lvl-2">
<p>IO密集型：进程的主要工作是加载IO并进行处理。</p>
</li>
</ul>
<p>  并发：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>是指多个进程同时运行，并完成一定任务。</p>
</li>
</ul>
<p>  临界区：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>是指多个进程同时运行时，同一时刻访问相同的代码和数据。</p>
</li>
</ul>
<p>  同步：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>强调的是进程间的执行需要按照某种先后顺序，即进程运行的时间是有序的。</p>
</li>
</ul>
<p>  互斥：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>强调的是对于某些共享资源的访问不能同时进行，同一时间只能有一定数量的进程访问这些共享资源。</p>
</li>
</ul>
<p>  进程常见的同步机制：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>信号量：解决了同步问题。</p>
</li>
<li class="lvl-2">
<p>互斥量：解决了互斥问题。是信号量的一种特例，只具备0，1两种值。</p>
</li>
</ul>
<br/>
<br/>
<br/>
<br/>
<h3 id="锁">锁</h3>
<hr>
<p>  锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>既可以解决同步问题，也可以解决互斥问题。</p>
</li>
</ul>
<p>  死锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>指多个进程同时获取锁，且由于某些原因，此锁永远不会被空闲。</p>
</li>
</ul>
<p>  两种基本锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>互斥锁：加锁失败后，线程会释放 CPU ，给其他线程；</p>
</li>
<li class="lvl-2">
<p>自旋锁：加锁失败后，线程会忙等待，直到它拿到锁；</p>
</li>
</ul>
<p>  读写锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>读锁：当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。</p>
</li>
<li class="lvl-2">
<p>写锁：一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞</p>
</li>
<li class="lvl-2">
<p>特征：读写锁在读多写少的场景，能发挥出优势。读写锁可以分为「读优先锁」和「写优先锁」</p>
</li>
</ul>
<p>  乐观锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果多线程同时修改共享资源的概率比较低</p>
</li>
</ul>
<p>  悲观锁：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>认为多线程同时修改共享资源的概率比较高，于是很容易出现冲突，所以访问共享资源前，先要上锁。</p>
</li>
</ul>
<br/>
<br/>
<br/>
<br/>
<h3 id="CAS-Compare-And-Swap">CAS(Compare And Swap)</h3>
<hr>
<p>  CAS是一种无锁同步算法，主要用于多线程环境下面，高效的对多个线程进行同步。</p>
<p>  首先CAS有3个重要的参数：目标地址(P)、期望值(E)、新值(N)，然后其工作原理是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>读取目标地址（P）的值</p>
</li>
<li class="lvl-2">
<p>对比目标地址（P）的值与期望值（E）</p>
</li>
<li class="lvl-2">
<p>如果P==E，则写入新值（N），如果P!=E，则不做任何操作并返回。</p>
</li>
</ul>
<p>  可以乍一看，这里有3步操作，会让我们对这个算法难以理解，所以这里还有一个重要的概念：CAS的这几步操作是原子的，一次性完成的，此外，这些特性是硬件提供的。因此，在实际使用上面，这些原子操作被编译器封装成相关的接口来使用这些硬件特性。例如gcc里面：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html</span>
<span class="token comment">// 注意，原来的__sync_*系列函数的__atomic系列替代了</span>
bool <span class="token function">__atomic_compare_exchange</span> <span class="token punctuation">(</span>type <span class="token operator">*</span>ptr<span class="token punctuation">,</span> type <span class="token operator">*</span>expected<span class="token punctuation">,</span> type <span class="token operator">*</span>desired<span class="token punctuation">,</span> bool weak<span class="token punctuation">,</span> <span class="token keyword">int</span> success_memorder<span class="token punctuation">,</span> <span class="token keyword">int</span> failure_memorder<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<br/>
<br/>
<h3 id="futex-系统调用">futex 系统调用</h3>
<hr>
<p>  futex是linux下用来实现各种同步机制的一个系统调用，我们先来学习看看其api：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/futex.h></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/time.h></span></span>

<span class="token keyword">int</span> <span class="token function">futex</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">int</span> futex_op<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>timeout<span class="token punctuation">,</span>   <span class="token comment">/* or: uint32_t val2 */</span>
            <span class="token keyword">int</span> <span class="token operator">*</span>uaddr2<span class="token punctuation">,</span> <span class="token keyword">int</span> val3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  注意这里的看到这个api有许多的参数，但是我们常用的也是前面4个，一般来说，我们会将futex分为常用的两类，是futex_op参数指定的，分别是：FUTEX_WAIT、FUTEX_WAKE（注意，还有其他很多op类型），其他的参数根据不同的类型，有不同的一些含义：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于FUTEX_WAIT来说：如果uaddr的值等于期待值（val），则将线程挂起。timeout如果是NULL，则无限等待，或者等待timeout时间。</p>
</li>
<li class="lvl-2">
<p>对于FUTEX_WAKE来说：指定唤醒uaddr关联的并被挂起的val个线程。timeout参数忽略。</p>
</li>
</ul>
<p>  上面我们简单说明了这个系统调用的一些用法，现在我们来看看这个系统调用的内核简单实现，然后我们就基本理解了这个系统调用的工作原理：</p>
<p>首先来看看FUTEX_WAIT的内核部分源码，如下：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//linux kernel v4.6 kernel/futex.c</span>

<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">queue_me</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">)</span>
	<span class="token function">__releases</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">int</span> prio<span class="token punctuation">;</span>

    <span class="token comment">// ... ... 省略</span>

	<span class="token function">plist_node_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">,</span> prio<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">plist_add</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>q<span class="token operator">-></span>list<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token operator">-></span>chain<span class="token punctuation">)</span><span class="token punctuation">;</span>
	q<span class="token operator">-></span>task <span class="token operator">=</span> current<span class="token punctuation">;</span>
	<span class="token function">spin_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>hb<span class="token operator">-></span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>


<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">futex_wait_queue_me</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span>
				<span class="token keyword">struct</span> <span class="token class-name">hrtimer_sleeper</span> <span class="token operator">*</span>timeout<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
    <span class="token comment">// ... ... 省略</span>
	<span class="token function">set_current_state</span><span class="token punctuation">(</span>TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//挂起</span>
	<span class="token function">queue_me</span><span class="token punctuation">(</span>q<span class="token punctuation">,</span> hb<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// ... ... 省略</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">futex_wait_setup</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> u32 val<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span>
			   <span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>q<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span><span class="token operator">*</span>hb<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	u32 uval<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// ... ... 省略</span>
    
retry<span class="token operator">:</span>
    <span class="token comment">// ... ... 省略</span>
    ret <span class="token operator">=</span> <span class="token function">get_futex_value_locked</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>uval<span class="token punctuation">,</span> uaddr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// ... ... 省略</span>

	ret <span class="token operator">=</span> <span class="token function">get_futex_key</span><span class="token punctuation">(</span>uaddr<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> FLAGS_SHARED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token operator">-></span>key<span class="token punctuation">,</span> VERIFY_READ<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// ... ... 省略</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>uval <span class="token operator">!=</span> val<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//判断值是否是期望值，并做后续操作</span>
		<span class="token function">queue_unlock</span><span class="token punctuation">(</span><span class="token operator">*</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
		ret <span class="token operator">=</span> <span class="token operator">-</span>EWOULDBLOCK<span class="token punctuation">;</span>
	<span class="token punctuation">&#125;</span>
    <span class="token comment">// ... ... 省略</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">futex_wait</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> u32 val<span class="token punctuation">,</span>
		      <span class="token class-name">ktime_t</span> <span class="token operator">*</span>abs_time<span class="token punctuation">,</span> u32 bitset<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">struct</span> <span class="token class-name">hrtimer_sleeper</span> timeout<span class="token punctuation">,</span> <span class="token operator">*</span>to <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">restart_block</span> <span class="token operator">*</span>restart<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_q</span> q <span class="token operator">=</span> futex_q_init<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">;</span>

    <span class="token comment">// ... ... 省略</span>

retry<span class="token operator">:</span>
	<span class="token comment">/*
	 * Prepare to wait on uaddr. On success, holds hb lock and increments
	 * q.key refs.
	 */</span>
	ret <span class="token operator">=</span> <span class="token function">futex_wait_setup</span><span class="token punctuation">(</span>uaddr<span class="token punctuation">,</span> val<span class="token punctuation">,</span> flags<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>

	<span class="token comment">/* queue_me and wait for wakeup, timeout, or a signal. */</span>
	<span class="token function">futex_wait_queue_me</span><span class="token punctuation">(</span>hb<span class="token punctuation">,</span> <span class="token operator">&amp;</span>q<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// ... ... 省略</span>

out<span class="token operator">:</span>
    <span class="token comment">// ... ... 省略</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  其实我们这里可以看到，关键是通过get_futex_key来根据传入的uaddr获取一个key，然后根据key，来构造一个hash list(注意，这时这个hash list被一个hash数据结构维护了，可通过key查询)，并将当前线程插入到这个list，并将线程/进程挂起。在这个过程中，还会检查*uaddr 是否等于val，否则做相关操作。</p>
<p>  现在，其实我们基本上也可以猜到FUTEX_WAKE的实现是什么样子，现在我们先来看看其源码节选：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//linux kernel v4.6 kernel/futex.c</span>
<span class="token keyword">static</span> <span class="token keyword">inline</span> <span class="token keyword">int</span> <span class="token function">match_futex</span><span class="token punctuation">(</span><span class="token keyword">union</span> futex_key <span class="token operator">*</span>key1<span class="token punctuation">,</span> <span class="token keyword">union</span> futex_key <span class="token operator">*</span>key2<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span>key1 <span class="token operator">&amp;&amp;</span> key2
		<span class="token operator">&amp;&amp;</span> key1<span class="token operator">-></span>both<span class="token punctuation">.</span>word <span class="token operator">==</span> key2<span class="token operator">-></span>both<span class="token punctuation">.</span>word
		<span class="token operator">&amp;&amp;</span> key1<span class="token operator">-></span>both<span class="token punctuation">.</span>ptr <span class="token operator">==</span> key2<span class="token operator">-></span>both<span class="token punctuation">.</span>ptr
		<span class="token operator">&amp;&amp;</span> key1<span class="token operator">-></span>both<span class="token punctuation">.</span>offset <span class="token operator">==</span> key2<span class="token operator">-></span>both<span class="token punctuation">.</span>offset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span>
<span class="token function">futex_wake_op</span><span class="token punctuation">(</span>u32 __user <span class="token operator">*</span>uaddr1<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> u32 __user <span class="token operator">*</span>uaddr2<span class="token punctuation">,</span>
	      <span class="token keyword">int</span> nr_wake<span class="token punctuation">,</span> <span class="token keyword">int</span> nr_wake2<span class="token punctuation">,</span> <span class="token keyword">int</span> op<span class="token punctuation">)</span>
<span class="token punctuation">&#123;</span>
	<span class="token keyword">union</span> futex_key key1 <span class="token operator">=</span> FUTEX_KEY_INIT<span class="token punctuation">,</span> key2 <span class="token operator">=</span> FUTEX_KEY_INIT<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_hash_bucket</span> <span class="token operator">*</span>hb1<span class="token punctuation">,</span> <span class="token operator">*</span>hb2<span class="token punctuation">;</span>
	<span class="token keyword">struct</span> <span class="token class-name">futex_q</span> <span class="token operator">*</span>this<span class="token punctuation">,</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
	<span class="token keyword">int</span> ret<span class="token punctuation">,</span> op_ret<span class="token punctuation">;</span>
	<span class="token function">WAKE_Q</span><span class="token punctuation">(</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span>

retry<span class="token operator">:</span>
	ret <span class="token operator">=</span> <span class="token function">get_futex_key</span><span class="token punctuation">(</span>uaddr1<span class="token punctuation">,</span> flags <span class="token operator">&amp;</span> FLAGS_SHARED<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key1<span class="token punctuation">,</span> VERIFY_READ<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据uaddr获取key</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">unlikely</span><span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">goto</span> out<span class="token punctuation">;</span>
    <span class="token comment">// ... ... 省略</span>

	hb1 <span class="token operator">=</span> <span class="token function">hash_futex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//根据key获取hash对象</span>

	<span class="token comment">// ... ... 省略</span>

retry_private<span class="token operator">:</span>
	<span class="token comment">// ... ... 省略</span>


	<span class="token function">plist_for_each_entry_safe</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> next<span class="token punctuation">,</span> <span class="token operator">&amp;</span>hb1<span class="token operator">-></span>chain<span class="token punctuation">,</span> list<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">match_futex</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>this<span class="token operator">-></span>key<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key1<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span><span class="token comment">//匹配符合条件的key</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>this<span class="token operator">-></span>pi_state <span class="token operator">||</span> this<span class="token operator">-></span>rt_waiter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
				ret <span class="token operator">=</span> <span class="token operator">-</span>EINVAL<span class="token punctuation">;</span>
				<span class="token keyword">goto</span> out_unlock<span class="token punctuation">;</span>
			<span class="token punctuation">&#125;</span>
			<span class="token function">mark_wake_futex</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake_q<span class="token punctuation">,</span> this<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将符合条件的对象放入到队列wake_q</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>ret <span class="token operator">>=</span> nr_wake<span class="token punctuation">)</span>
				<span class="token keyword">break</span><span class="token punctuation">;</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

    <span class="token comment">// ... ... 省略</span>

out_unlock<span class="token operator">:</span>
	<span class="token function">double_unlock_hb</span><span class="token punctuation">(</span>hb1<span class="token punctuation">,</span> hb2<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">wake_up_q</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wake_q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//唤醒线程/进程，wake_up_q在kernel/sched/core.c中定义</span>
out_put_keys<span class="token operator">:</span>
	<span class="token function">put_futex_key</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key2<span class="token punctuation">)</span><span class="token punctuation">;</span>
out_put_key1<span class="token operator">:</span>
	<span class="token function">put_futex_key</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>key1<span class="token punctuation">)</span><span class="token punctuation">;</span>
out<span class="token operator">:</span>
	<span class="token keyword">return</span> ret<span class="token punctuation">;</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  从这里我们可以看到，首先我们根据uaddr获取了key，然后通过hash_futex获取key对象，这个时候我们就获取了和uaddr相关的线程/进程list。然后我们遍历list，将符合条件的线程/进程放到wake_q队列中去，最后通过wake_up_q来设置TASK_WAKING，并唤醒线程/进程。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  从这里我们可以看到，这些概念是为了解决前置问题逐步引入的：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>进程具备一定的状态（运行、就绪、等待（阻塞/睡眠） + 新建、终止）。</p>
</li>
<li class="lvl-2">
<p>进程是OS调度的基本单位，调度就是调整进程的状态。</p>
</li>
<li class="lvl-2">
<p>为了高效完成一个任务，我们需要并发，这时我们需要同步，需要信号量。</p>
</li>
<li class="lvl-2">
<p>因为有了并发，我们需要注意临界区。</p>
</li>
<li class="lvl-2">
<p>有了临界区，我们需要互斥量（锁）。</p>
</li>
<li class="lvl-2">
<p>最后，CAS和futex可以实现各种信号量和锁。</p>
</li>
</ul>
<p>  完结散花。</p>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><a target="_blank" rel="noopener" href="https://man7.org/linux/man-pages/man2/futex.2.html">https://man7.org/linux/man-pages/man2/futex.2.html</a></p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://e-x.top/2024/03/16/blog_idx_127/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Sky">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sky's Blogs">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content=" | Sky's Blogs">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2024/03/16/blog_idx_127/" class="post-title-link" itemprop="url">常用加密及其相关的概念、简介（对称、AES、非对称、RSA、散列、HASH、消息认证码、HMAC、签名、CA、数字证书、base64、填充）</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2024-03-16 11:18:00" itemprop="dateCreated datePublished" datetime="2024-03-16T11:18:00+08:00">2024-03-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2024-05-18 19:06:02" itemprop="dateModified" datetime="2024-05-18T19:06:02+08:00">2024-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">常识</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%B8%B8%E8%AF%86/C-CPP/" itemprop="url" rel="index"><span itemprop="name">C&CPP</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <script src="\assets\js\APlayer.min.js"> </script><!--
 * @Description: 
 * @Author: Sky
 * @Date: 2020-08-24 16:37:34
 * @LastEditors: Sky
 * @LastEditTime: 2021-06-29 15:04:48
 * @Github: https://github.com/flyinskyin2013/
-->
<p><font color="red" size="7">PS：要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 这个只是基于《我自己》的理解，</font><br/><font color="red" size="7">如果和你的原则及想法相冲突，请谅解，勿喷。</font><br/></p>
<!-- ###### 前置说明
&emsp;&emsp;本文作为本人github blog/cnblog的主站的备份。（BlogID=127） 
&emsp;&emsp;本文发布于 2024-03-16 11:18:00             （BlogID=127） 
-->
<h6 id="环境说明">环境说明</h6>
<p>  无</p>
<h3 id="前言">前言</h3>
<hr>
<p>  在之前，一直是通过生活、工作零零碎碎接触过加密及加密算法相关的信息，但是也只是听说过，并不知道这些算法用处和区别。</p>
<p>  最近由于工作安排，需要将Fernet算法实现一版C++的加解密定制程序，由于Fernet组合了许多的基础加密算法，因此在这个地方，对一些常用的基础加密算法做一个总结。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="加密是什么？">加密是什么？</h3>
<hr>
<p>  介绍：把“原始数据”通过某种算法+秘钥变换后，得到了“加密数据”的这个过程叫做加密。从这里也可以看到，对于加密来说，其核心要素就是：加密算法+秘钥。</p>
<p>  意义：对于“加密数据”来说，未授权的用户，不能够直接知道“原始数据”的内容。</p>
<p>  下面介绍一些常见的加密类别和加密相关配套的其他内容。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="对称加密">对称加密</h3>
<hr>
<p>  对称加密是指使用 一个相同秘钥 就能对消息进行加密和解密的加密方法。</p>
<p>  对称加密的特点就是使用 一个相同秘钥。</p>
<p>  我们常见的对称加密有：XOR、AES等。下面我们来简单分析一下AES加密。</p>
<br/>
<br/>
<h5 id="AES加密">AES加密</h5>
<p>  高级加密标准（Advanced Encryption Standard，AES），是一种区块加密标准。从它的定义来看，其特点是区块加密，一般来说，我们常见的有AES128和AES256。</p>
<p>  例如我们可以用如下的openssl提供的方法进行AES的加解密：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">AES_set_encrypt_key</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>userKey<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bits<span class="token punctuation">,</span>
                        AES_KEY <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">AES_set_decrypt_key</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>userKey<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">int</span> bits<span class="token punctuation">,</span>
                        AES_KEY <span class="token operator">*</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//注意这里只是一种cbc加密方法，aes还有很多其他加密方法</span>
<span class="token keyword">void</span> <span class="token function">AES_cbc_encrypt</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>in<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>out<span class="token punctuation">,</span>
                     <span class="token class-name">size_t</span> length<span class="token punctuation">,</span> <span class="token keyword">const</span> AES_KEY <span class="token operator">*</span>key<span class="token punctuation">,</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  其实我们从上面的描述来看，就知道AES一般以16字节或者32字节为一组（我们将其定义为区块大小），进行加密。这里就会引申出一个问题，如果我们的数据（最后一组消息）不够一个区块大小，我们应该怎么办？这里提供的常见方案就是做填充。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="非对称加密（公钥加密算法）">非对称加密（公钥加密算法）</h3>
<hr>
<p>  我们知道，加密一般是用于消息传递，那么如果是对称加密的情况下，要传递的两个事务：加密消息+秘钥。对于对称加密来说，如果我们的秘钥泄露了，就基本上等于明文传递了。因此，有了非对称加密。其实后面很多的加密方法就在平衡 加密消息+秘钥 两个事情。</p>
<p>  非对称加密就是有两个秘钥（私钥，公钥），实现1对多的双向通信。其中我们常见的加密方式是：RSA，ECC等。下面，我们尝试简单介绍RSA。</p>
<br/>
<br/>
<h5 id="RSA-加密算法">RSA 加密算法</h5>
<p>  简介（来自于Wikipedia）：RSA加密算法是一种非对称加密算法。RSA是由罗纳德·李维斯特（Ron Rivest）、阿迪·萨莫尔（Adi Shamir）和伦纳德·阿德曼（Leonard Adleman）在1977年一起提出的。当时他们三人都在麻省理工学院工作。RSA 就是他们三人姓氏开头字母拼在一起组成的。</p>
<p>  RSA只从使用的角度来说，只需要了解如下的大致的概念：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>模数N、公钥指数pubE、私钥指数priE</p>
</li>
<li class="lvl-2">
<p>加密：秘文=明文^priE mod N，秘文=明文^pubE mod N</p>
</li>
<li class="lvl-2">
<p>解密：明文=秘文^pubE mod N，明文=秘文^priE mod N</p>
</li>
</ul>
<p>  从上面来看，私钥= 私钥指数priE + 模数N，公钥= 公钥指数pubE + 模数N。至于公钥，私钥，模数怎么来的，网上已有许多资料，有兴趣可以去看看。</p>
<p>  基于openssl的RSA代码节选：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">// 生成秘钥，秘钥里面包含了私钥+公钥</span>
<span class="token keyword">int</span> <span class="token function">RSA_generate_key_ex</span><span class="token punctuation">(</span>RSA <span class="token operator">*</span>rsa<span class="token punctuation">,</span> <span class="token keyword">int</span> bits<span class="token punctuation">,</span> BIGNUM <span class="token operator">*</span>e<span class="token punctuation">,</span> BN_GENCB <span class="token operator">*</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 基于公钥和私钥的加解密</span>
<span class="token keyword">int</span> <span class="token function">RSA_public_encrypt</span><span class="token punctuation">(</span><span class="token keyword">int</span> flen<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>from<span class="token punctuation">,</span>
                       <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> RSA <span class="token operator">*</span>rsa<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">RSA_private_encrypt</span><span class="token punctuation">(</span><span class="token keyword">int</span> flen<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>from<span class="token punctuation">,</span>
                        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> RSA <span class="token operator">*</span>rsa<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">RSA_public_decrypt</span><span class="token punctuation">(</span><span class="token keyword">int</span> flen<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>from<span class="token punctuation">,</span>
                       <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> RSA <span class="token operator">*</span>rsa<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">RSA_private_decrypt</span><span class="token punctuation">(</span><span class="token keyword">int</span> flen<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>from<span class="token punctuation">,</span>
                        <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>to<span class="token punctuation">,</span> RSA <span class="token operator">*</span>rsa<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<br/>
<br/>
<h3 id="散列函数（Hash-function）">散列函数（Hash function）</h3>
<hr>
<p>  介绍：使用 散列函数（md5, sha1, sha256） 对原始数据进行处理，生成散列值（数字摘要）。这些散列函数保证一个输入对应一个输出，并且通过散列值无法得到原始数据输入，因此不属于加密。</p>
<p>  此外，如果散列函数不够健壮，可能会出现碰撞的可能性。</p>
<p>  意义：由于其不同的数据输入会得到不同的散列值，因此主要用来校验数据的完整性。</p>
<p>  基于openssl的常见散列函数代码节选：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//注意，根据官网的描述，如下这些接口已经逐步被弃用，这里只是起示例作用。</span>
<span class="token keyword">int</span> <span class="token function">SHA1_Init</span><span class="token punctuation">(</span>SHA_CTX <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">SHA1_Update</span><span class="token punctuation">(</span>SHA_CTX <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">SHA1_Final</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>md<span class="token punctuation">,</span> SHA_CTX <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//注意，根据官网的描述，如下这些接口已经逐步被弃用，这里只是起示例作用。</span>
<span class="token keyword">int</span> <span class="token function">SHA256_Init</span><span class="token punctuation">(</span>SHA256_CTX <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">SHA256_Update</span><span class="token punctuation">(</span>SHA256_CTX <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>data<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">SHA256_Final</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>md<span class="token punctuation">,</span> SHA256_CTX <span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  其实做过编程的人，对hash这个概念并不陌生。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="消息认证码">消息认证码</h3>
<hr>
<p>  含义：使用 散列函数+秘钥来生成认证码（MAC）。相较于散列函数来说，对于同一个消息，需要指定的秘钥+散列函数才能够得到最终的认证码。</p>
<p>  意义：在散列函数中，原始数据和散列值是绑定的。在一个消息传递系统中，散列函数只解决了数据完整性的问题，并没有解决数据来源是否可靠的问题（可以伪造原始数据+新散列值）。 通过消息验证码，由于有了秘钥的保护， 解决了 散列值+消息 来源不可靠的问题。</p>
<p>  基于openssl的消息认证码代码节选：</p>
<pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">//这里的evp_md用来描述不同的散列函数</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">HMAC</span><span class="token punctuation">(</span><span class="token keyword">const</span> EVP_MD <span class="token operator">*</span>evp_md<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>key<span class="token punctuation">,</span>
                     <span class="token keyword">int</span> key_len<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token class-name">size_t</span> n<span class="token punctuation">,</span>
                     <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>md<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token operator">*</span>md_len<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<br/>
<br/>
<br/>
<br/>
<h3 id="签名算法">签名算法</h3>
<hr>
<p>  下面是签名的一个简单流程：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>基于公钥加密系统，生成秘钥对（公钥、私钥）。</p>
</li>
<li class="lvl-2">
<p>对消息进行数字摘要计算。</p>
</li>
<li class="lvl-2">
<p>对数字摘要进行私钥加密，得到数字签名。</p>
</li>
<li class="lvl-2">
<p>将信息、数字签名、公钥发给接收者，接收者可以验证：信息的完整性+发送者的身份。</p>
</li>
</ul>
<p>  从这里来看，我们可以知道，签名其实和消息认证码具有相同的意义，都能够验证：完整性+发送者的身份。但是由于其原理，导致其应用场景不一致。例如：数字签名由于使用非对称加密，而消息认证码可以认为是使用了对称加密，导致他们的使用场景是不一样的。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="CA机构与数字证书">CA机构与数字证书</h3>
<hr>
<p>  其实从名字上来看，就知道CA机构与数字证书和签名算法相关，为了解决公钥加密系统中，公钥是否可信的问题。下面是它们的一些概念：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>CA（Certificate Authority）是“证书颁发机构”的简称，它是“受信任”的第三方组织，负责验证申请者身份并发放数字证书。</p>
</li>
<li class="lvl-2">
<p>数字证书是：特定用户或系统身份信息（如域名、组织名等）+ 该用户公钥 + 由权威机构（CA）签署的数字签名（对用户的信息+公钥） 组成的数据结构。</p>
</li>
</ul>
<p>  简单来说，由于我们信任了CA的证书（CA的公钥），我们可以用CA的公钥解密出 数字证书用户的公钥，然后我们用 数字证书用户的公钥 和 数字证书用户加密通信。总的来说，数字证书其实是一个信任链的问题。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="Base64-编码">Base64 编码</h3>
<hr>
<p>  介绍：一种将 二进制数据 编码为 可见字符 的编码方法。简单来说就是用 4个字节的可见字符 代替是 3个字节数据 的编码过程。</p>
<p>  意义：可以将二进制数据表达为文本信息，方便后续对二进制数据进行处理。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="数据区块填充，PKCS（Public-Key-Cryptography-Standards）">数据区块填充，PKCS（Public-Key Cryptography Standards）</h3>
<hr>
<p>  特别说明，PKCS是一系列公钥密码标准，里面具备很多的内容，其大概有15个标准，分别是pkcs1,pkcs2 … … pkcs14,pkcs15</p>
<p>  从上面我们知道，现在常用的填充方法是：公钥加密标准（PKCS，Public-Key Cryptography Standards）里面的节选内容。其有很多填充类别，例如：PKCS1-padding节选, PKCS5-padding节选, PKCS7-padding节选，我们这里只讨论pkcs5和pkcs7。（注意，这些标准除了数据填充，还有其他定义内容。）</p>
<p>  下面先介绍PKCS5-padding，先定义数据区块大小为SIZE，pkcs5和pkcs7的填充说明，下面以SIZE=8字节举例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>要填充7个字节,那么填入的值就是0×07;</p>
</li>
<li class="lvl-2">
<p>如果只填充１个字节，那么填入的值就是0×01;</p>
</li>
<li class="lvl-2">
<p>数据恰好是8的倍数时还要补8个字节的0×08。</p>
</li>
</ul>
<p>  从上面的PKCS5-padding，我们可以知道，这里需要数据区块固定为8字节。如果我们想给其他大小的数据区块做数据对齐，那么PKCS5-padding就不满足要求，因此就有PKCS7-padding的填充方法：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>PKCS7-padding的数据区块大小可以是：1-255字节。</p>
</li>
<li class="lvl-2">
<p>其他的，PKCS7-padding填充原理和PKCS5一样。</p>
</li>
</ul>
<p>  从上面可知，PKCS7-padding节选包含了PKCS5-padding节选，且适用性范围更加的广泛。</p>
<p>  到了这里，我们就能够对AES128或者AES256做基于PKCS7-padding的16字节对齐或者32字节对齐的操作了。</p>
<p>  这里的代码实现很简单，这里提供一种方法，大概就是：首先对消息进行强制扩大255字节，然后根据数据区块大小做填充即可，基本可以实现pkcs7填充的原理。</p>
<br/>
<br/>
<br/>
<br/>
<h3 id="后记">后记</h3>
<hr>
<p>  其实，我们从上面的内容来看，能发现一些规律：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>由于信任链的存在，因此有了CA机构和数字证书，而数字证书与签名算法相关，而签名算法又与 非对称加密和散列函数强相关。</p>
</li>
<li class="lvl-2">
<p>然后为了实现我们现在常见的加密系统，我们使用了：对称加密、非对称加密、散列函数、消息认证码和base64编码等手段。</p>
</li>
</ul>
<h3 id="参考文献">参考文献</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>无</p>
</li>
</ul>
<br/>
<br/>
<div style="margin:50px auto;">
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <hr/>
        <center><font color = #91e0b0 size = 5>打赏、订阅、收藏、丢香蕉、硬币，请关注公众号（攻城狮的搬砖之路）</font></center>
    </div>
</div>
<div style="text-align:center">
    <div style="margin:0 auto;">
        <center><img src="https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg" alt="qrc_img"/></center>
    </div>
</div>
<!-- ![alt 公众号图片](https://flyinskyin2013.github.io/ImageBed0/blogs/qrcode_for_wx_official_account.jpg "公众号图片") -->
<p><font color="red" size="7">PS: 请尊重原创，不喜勿喷。</font><br/><br>
<font color="red" size="7">PS: 要转载请注明出处，本人版权所有。</font><br/><br>
<font color="red" size="7">PS: 有问题请留言，看到后我会第一时间回复。</font><br/></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/NO_EXSIT.XXXXXXX/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/NO_EXSIT.XXXXXXX/">1</a><span class="page-number current">2</span><a class="page-number" href="/NO_EXSIT.XXXXXXX/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/NO_EXSIT.XXXXXXX/page/14/">14</a><a class="extend next" rel="next" title="下一页" aria-label="下一页" href="/NO_EXSIT.XXXXXXX/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Sky</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">286k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">17:19</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":250,"hOffset":50,"vOffset":5},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body>
</html>
